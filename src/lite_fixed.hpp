 /***********************************************************************************************************
     array.hpp
     Copyright Saeed Alaei 2007-2009.
     Version : 3.505
     Generated on: Fri Nov 06 02:03:07 2009
 
     Warning: This file is generated. If you need to make a change, modify the template.
     To generate the documentation, run Doxygen on this file.
 
     Permission is hereby granted, free of charge, to any person or organization
     obtaining a copy of the software and accompanying documentation covered by
     this license (the "Software") to use, reproduce, display, distribute,
     execute, and transmit the Software, and to prepare derivative works of the
     Software, and to permit third-parties to whom the Software is furnished to
     do so, all subject to the following:
 
     The copyright notices in the Software and this entire statement, including
     the above license grant, this restriction and the following disclaimer,
     must be included in all copies of the Software, in whole or in part, and
     all derivative works of the Software, unless such copies or derivative
     works are solely in the form of machine-executable object code generated by
     a source language processor.
 
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
 
     Trivia: 
     This whole file was written from scratch from 9/4/2009 to 9/10/2009 excluding the documentation.
 ***********************************************************************************************************/
 
 /* 
 FUTURE TODO:
     - (high) add the dimension selection for for_each functions 
     - (medium) add resize error checking
     - (very low) add xformat formating
     - (very low) do something about internal_rep with variable length abuse!
     - (very low) elaborate the default_array_traits
     - (very low) add stl style vector operations.
     - (very low) add specialized operations for 0-dimension arrays.
 */
 
 #ifndef LITE_ARRAY_HPP
 #define LITE_ARRAY_HPP
 
 #include <exception>
 #include <stdexcept>
 #include <iterator>
 #include <algorithm>
 #include <iostream>
 #include <iomanip>
 #include <limits>
 #include <cmath>
 #include <cstdlib>
 
 /***********************************************************************************************************/
 /* common configuration ************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef LITE_INLINE
 #undef LITE_INLINE
 #endif
 
 #define LITE_ARRAY_MAX_DIMS 4
 
 #define LITE_ARRAY_MAX_PACKS 4
 
 #define LITE_ARRAY_MAX_VECTOR_ARGS 5
 
 #define LITE_ARRAY_MAX_ITERATOR_ARGS 4
 
 #define LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH 5
 
 #define LITE_ARRAY_MAX_DYNAMIC_UNROLL_DEPTH 4
 
 #define LITE_ARRAY_VERSION 3505
 
 #define LITE_ARRAY_VERSION_STR "3.505"
 
 #define LITE_ARRAY_USE(x) ((void)(x))
 
 #ifndef __LINE__ // true when Doxygen is processing the file
 #define DOCUMENTATION_ONLY
 #endif 
 
 /***********************************************************************************************************/
 /* MSVC++ configuration ************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef _MSC_VER
 
 #if _MSC_VER < 1300
 #error visual c++ .net 7.1 (2003) or newer is required
 #endif // _MSC_VER < 1300 
 
 #pragma warning(push)
 #pragma warning(disable : 4127) // conditional_c expression is constant
 #pragma inline_recursion(on)
 #pragma inline_depth(200)
 
 #define LITE_INLINE __forceinline
 
 #ifndef NDEBUG
 #pragma message ("lite/array.hpp: Warning! Possible performance penalty due to assertions. Define NDEBUG to disable.")
 #endif
 
 #endif // _MSC_VER
 
 /***********************************************************************************************************/
 /* GCC configuration ***************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef __GNUC__
 
 #define LITE_INLINE  inline __attribute__((always_inline))
 
 #ifndef LITE_ARRAY_NO_HINT
 #warning "Use the following compiler switches to get a good performance: -finline-limit=1234567 --param large-function-growth=1234567 --param max-inline-insns-single=1234567"
 #warning "Define LITE_ARRAY_NO_HINT to disable the previous warning."
 #endif 
 
 #ifndef NDEBUG
 #warning "lite/array.hpp: Possible performance penalty due to assertions. Define NDEBUG to disable."
 #endif
 
 #endif // __GNUC__
 
 /***********************************************************************************************************/
 /* generic configuration ***********************************************************************************/
 /***********************************************************************************************************/
 
 #ifndef LITE_INLINE
 #define LITE_INLINE inline
 #endif
 
 /***********************************************************************************************************/
 /* error checking/debug level ******************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef NDEBUG
 #define LITE_ARRAY_SIZE_CHECK(size1, size2, msg)
 #else
 #define LITE_ARRAY_SIZE_CHECK(size1, size2, msg) lite_array_size_check(size1, size2, msg)
 #endif
 
 /***********************************************************************************************************/
 /* namespace lite ******************************************************************************************/
 /***********************************************************************************************************/
 
 namespace lite
 {
 
 template<typename type_, type_ value_>
 class constant;
 
 template<
     typename type0_ = void ,
     typename type1_ = void ,
     typename type2_ = void ,
     typename type3_ = void 
     >
 class pack;
 
 template<
     typename pack_type_,
     bool keep0_ =false,
     bool keep1_ =false,
     bool keep2_ =false,
     bool keep3_ =false
     >
 class sub_pack;
 
 // class s_iterator; // the pack class is used directly instead
 
 template<typename _value_type>
 class c_iterator; // const_iterator
 
 template<
     typename base_iter_type_, 
     typename func_type_, 
     bool is_static_ =true>
 class u_iterator; // unary iterator
 
 template<
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     bool is_static_=true>
 class b_iterator; // binary_iterator
 
 template<typename signature_, typename base_iterator_type_=void>
 struct array_signature_traits;
 
 template<typename iterator_type_>
 class reference_rep;
 
 template<bool reversed_>
 class internal_rep;
 
 template<bool reversed_, int internal_buf_size_>
 class hybrid_rep;
 
 struct default_array_traits;
 
 template<
     typename signature_, 
     typename traits_type_ = default_array_traits, 
     typename rep_ = typename traits_type_::template representation_type<signature_>::type>
 class array;
 
 template<typename signature_, typename traits_type_ = default_array_traits>
 struct array_helper;
 
 template<typename trans_type_, typename size_type_>
 struct size_transformer;
 
 template<typename trans_type_, typename iter_type_, typename size_type_>
 struct iterator_transformer;
 
 template<typename array_type_, typename trans_type_, typename enabler_=void>
 struct transform_traits;
 
 template<int dim_>
 class plane;
 
 typedef plane<0> row;
 
 typedef plane<1> column;
 
 class diagonal;
 
 class transpose;
 
 template<
     int n0_ = -2,
     int n1_ = -2,
     int n2_ = -2
     >
 class block;
 
 class array_comparator;
 
 class size_mismatch_error;
 
 namespace transforms 
 {
 using ::lite::plane;
 using ::lite::row;
 using ::lite::column;
 using ::lite::diagonal;
 using ::lite::transpose;
 using ::lite::block;
 using ::lite::transform_traits;
 };
 
 /***********************************************************************************************************/
 /* implementation helpers **********************************************************************************/
 /***********************************************************************************************************/
 
 namespace detail
 {
 
 /***********************************************************************************************************/
 /* enable_if ***********************************************************************************************/
 /***********************************************************************************************************/
 
 template<bool cond_, typename type_ =void>
 struct enable_if;
 
 template<typename type_>
 struct enable_if<false, type_>
 {};
 
 template<typename type_>
 struct enable_if<true, type_>
 {
     typedef type_ type;
 };
 
 /***********************************************************************************************************/
 /* type_if *************************************************************************************************/
 /***********************************************************************************************************/
 
 template<bool cond_, typename true_type_, typename false_type_>
 struct type_if;
 
 template<typename true_type_, typename false_type_>
 struct type_if<true, true_type_, false_type_>
 {
     typedef true_type_ type;
 };
 
 template<typename true_type_, typename false_type_>
 struct type_if<false, true_type_, false_type_>
 {
     typedef false_type_ type;
 };
 
 struct invalid_argument {};
 
 /***********************************************************************************************************/
 /* same_type ***********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename left_type_, typename right_type_>
 struct same_type
 {
     static const bool result = false;
 };
 
 template<typename type_>
 struct same_type<type_, type_>
 {
     static const bool result = true;
 };
 
 /***********************************************************************************************************/
 /* defined *************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename type_>
 struct defined
 {
     static const bool value = true;
 };
 
 /***********************************************************************************************************/
 /* compile_time_assert **************************************************************************************/
 /***********************************************************************************************************/
 
 template<bool cond_>
 struct compile_time_assert;
 
 template<>
 struct compile_time_assert<true>
 {
     typedef void verified;
 };
 
 /***********************************************************************************************************/
 /* remove **************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_4
 {
     typedef type_ type;
     typedef other_ other;
 };
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_4<volatile type_, volatile stencil_, other_>
 {
     typedef type_ type;
     typedef volatile other_ other;
 };
 
 /***********************************************************************************************************/
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_3
 {
     typedef typename remove_4<type_, stencil_, other_>::type type;
     typedef typename remove_4<type_, stencil_, other_>::other other;
 };
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_3<const type_, const stencil_, other_>
 {
     typedef typename remove_4<type_, stencil_, other_>::type type;
     typedef const typename remove_4<type_, stencil_, other_>::other other;
 };
 
 /***********************************************************************************************************/
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_2
 {
     typedef typename remove_3<type_, stencil_, other_>::type type;
     typedef typename remove_3<type_, stencil_, other_>::other other;
 };
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_2<type_*, stencil_*, other_>
 {
     typedef typename remove_3<type_, stencil_, other_>::type type;
     typedef typename remove_3<type_, stencil_, other_>::other* other;
 };
 
 /***********************************************************************************************************/
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_1
 {
     typedef typename remove_2<type_, stencil_, other_>::type type;
     typedef typename remove_2<type_, stencil_, other_>::other other;
 };
 
 template<typename type_, typename stencil_, typename other_>
 struct remove_1<type_&, stencil_&, other_>
 {
     typedef typename remove_2<type_, stencil_, other_>::type type;
     typedef typename remove_2<type_, stencil_, other_>::other& other;
 };
 
 /***********************************************************************************************************/
 
 template<typename type_, typename stencil_, typename other_=int>
 struct remove
 {
     typedef typename remove_1<type_, stencil_, other_>::type type;
     typedef typename remove_1<type_, stencil_, other_>::other other;
 };
 
 /***********************************************************************************************************/
 /* size_to_signature ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename dim_type_>
 struct dim_type_to_sig;
 
 template<>
 struct dim_type_to_sig<int>
 { static const int n = 1; };
 
 template<int n_>
 struct dim_type_to_sig<constant<int, n_> >
 { static const int n = n_; };
 
 template<typename size_type_, typename value_type_>
 struct size_to_signature;
 
 
 template<
     typename value_type_>
 struct size_to_signature<pack<
     >,
     value_type_>
 {
     typedef value_type_ type
     ;
 };
 
 template<
     typename type0_,
     typename value_type_>
 struct size_to_signature<pack<
     type0_
     >,
     value_type_>
 {
     typedef value_type_ type
         [dim_type_to_sig<type0_>::n]
     ;
 };
 
 template<
     typename type0_,
     typename type1_,
     typename value_type_>
 struct size_to_signature<pack<
     type0_,
     type1_
     >,
     value_type_>
 {
     typedef value_type_ type
         [dim_type_to_sig<type0_>::n]
         [dim_type_to_sig<type1_>::n]
     ;
 };
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename value_type_>
 struct size_to_signature<pack<
     type0_,
     type1_,
     type2_
     >,
     value_type_>
 {
     typedef value_type_ type
         [dim_type_to_sig<type0_>::n]
         [dim_type_to_sig<type1_>::n]
         [dim_type_to_sig<type2_>::n]
     ;
 };
 
 } // namespace detail
 
 /***********************************************************************************************************/
 /* size_mismatch_error *************************************************************************************/
 /***********************************************************************************************************/
 
 class size_mismatch_error
     : public std::runtime_error
 {
 public:
     size_mismatch_error(const std::string& msg ="")
         : std::runtime_error(msg) 
     {}
 
     ~size_mismatch_error() throw() {}
 };
 
 /***********************************************************************************************************/
 /* pack ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename type_, type_ value_>
 class constant 
 {
 public:
     typedef type_ type; 
     static const type_ value = value_; 
 };
 
 template<typename type_, type_ value_>
 const type_ constant<type_, value_>::value;
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename type0_ ..., typename typeN_>
 class pack
 {
 public:
     static const int n = N+1; 
 
     typedef ... typeX; 
 
     static const bool is_constX = ...; 
 
     static const bool is_all_const = ...; 
 
     static const typeX iX = valueX_; 
     
     typeX iX; 
 
     pack();
     
     pack(const type0& a0);
 
     pack(const type0& a0, ... , const typeN& aN);
 
     template<typename other_type0_, ... , typename other_typeN_>
     pack(const pack<other_type0_, ... , other_typeN_>& other);
 
     pack& 
     operator= (const pack& other);
 
     template<typename other_type0_, ... , typename other_typeN_>
     pack& 
     operator= (const pack<other_type0_, ... , other_typeN_>& other);
 
     void set(const type0& a0, ... , const typeN& aN);
 };
 
 #else // DOCUMENTATION_ONLY
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class pack
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     type2 i2;
     type3 i3;
 
     LITE_INLINE pack() 
         : i0(),i1(),i2(),i3()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& a2,
         const type3& a3
         ) : i0(a0), i1(a1), i2(a2), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i1(other.i1), i2(other.i2), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& a2,
         const type3& a3
         ) 
     {
             i0 = a0;
             i1 = a1;
             i2 = a2;
             i3 = a3;
     }
 };
 
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     type2_,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     type2 i2;
     type3 i3;
 
     LITE_INLINE pack() 
         : i1(),i2(),i3()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& a2,
         const type3& a3
         ) : i1(a1), i2(a2), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i1(other.i1), i2(other.i2), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& a2,
         const type3& a3
         ) 
     {
             i1 = a1;
             i2 = a2;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     type2_,
     type3_
     >::i0;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     type2_,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     type2 i2;
     type3 i3;
 
     LITE_INLINE pack() 
         : i0(),i2(),i3()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& a2,
         const type3& a3
         ) : i0(a0), i2(a2), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i2(other.i2), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& a2,
         const type3& a3
         ) 
     {
             i0 = a0;
             i2 = a2;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     type2_,
     type3_
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     type2 i2;
     type3 i3;
 
     LITE_INLINE pack() 
         : i2(),i3()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& a2,
         const type3& a3
         ) : i2(a2), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i2(other.i2), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i2 = other.i2;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& a2,
         const type3& a3
         ) 
     {
             i2 = a2;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     type3_
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     type3_
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 class pack<
     type0_,
     type1_,
     constant<type2_, value2_>,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     static const type2 i2 = value2_;
     type3 i3;
 
     LITE_INLINE pack() 
         : i0(),i1(),i3()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& ,
         const type3& a3
         ) : i0(a0), i1(a1), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i1(other.i1), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& ,
         const type3& a3
         ) 
     {
             i0 = a0;
             i1 = a1;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type2_ pack<
     type0_,
     type1_,
     constant<type2_, value2_>,
     type3_
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     static const type2 i2 = value2_;
     type3 i3;
 
     LITE_INLINE pack() 
         : i1(),i3()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& ,
         const type3& a3
         ) : i1(a1), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i1(other.i1), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i1 = other.i1;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& ,
         const type3& a3
         ) 
     {
             i1 = a1;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     type3_
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     type3_
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
     type3 i3;
 
     LITE_INLINE pack() 
         : i0(),i3()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& ,
         const type3& a3
         ) : i0(a0), i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& ,
         const type3& a3
         ) 
     {
             i0 = a0;
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >::i1;
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type2_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_const3 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
     type3 i3;
 
     LITE_INLINE pack() 
         : i3()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& ,
         const type3& a3
         ) : i3(a3) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i3(other.i3)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i3 = other.i3;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i3 = other.i3;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& ,
         const type3& a3
         ) 
     {
             i3 = a3;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >::i1;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     type3_
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 class pack<
     type0_,
     type1_,
     type2_,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     type2 i2;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i0(),i1(),i2()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& a2,
         const type3& 
         ) : i0(a0), i1(a1), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& a2,
         const type3& 
         ) 
     {
             i0 = a0;
             i1 = a1;
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     type0_,
     type1_,
     type2_,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     type2_,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     type2 i2;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i1(),i2()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& a2,
         const type3& 
         ) : i1(a1), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i1(other.i1), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& a2,
         const type3& 
         ) 
     {
             i1 = a1;
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     type2_,
     constant<type3_, value3_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     constant<type0_, value0_>,
     type1_,
     type2_,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     type2 i2;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i0(),i2()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& a2,
         const type3& 
         ) : i0(a0), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& a2,
         const type3& 
         ) 
     {
             i0 = a0;
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >::i1;
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     type0_,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     type2 i2;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i2()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& a2,
         const type3& 
         ) : i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& a2,
         const type3& 
         ) 
     {
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >::i1;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 class pack<
     type0_,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     static const type2 i2 = value2_;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i0(),i1()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& ,
         const type3& 
         ) : i0(a0), i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0), i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& ,
         const type3& 
         ) 
     {
             i0 = a0;
             i1 = a1;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type2_ pack<
     type0_,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i2;
 
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     type0_,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     static const type2 i2 = value2_;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i1()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& ,
         const type3& 
         ) : i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& ,
         const type3& 
         ) 
     {
             i1 = a1;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i2;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_const3 = true;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
         : i0()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& ,
         const type3& 
         ) : i0(a0) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) : i0(other.i0)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& ,
         const type3& 
         ) 
     {
             i0 = a0;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i1;
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type2_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i2;
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >
 {
 public:
     static const int n = 4;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
     typedef type3_ type3;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_const3 = true;
     static const bool is_all_const = true;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
     static const type3 i3 = value3_;
 
     LITE_INLINE pack() 
              {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& ,
         const type3& 
         )  {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& )     {}
 
     LITE_INLINE pack& 
     operator= (const pack& ) 
     {
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ ,
         typename other_type3_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_,
         other_type3_
         >& ) 
     {
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& ,
         const type3& 
         ) 
     {
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i1;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i2;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_,
     typename type3_, type3_ value3_
     >
 const type3_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>,
     constant<type3_, value3_>
     >::i3;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class pack<
     type0_,
     type1_,
     type2_
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     type2 i2;
 
     LITE_INLINE pack() 
         : i0(),i1(),i2()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& a2
         ) : i0(a0), i1(a1), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& a2
         ) 
     {
             i0 = a0;
             i1 = a1;
             i2 = a2;
     }
 };
 
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     type2_
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     type2 i2;
 
     LITE_INLINE pack() 
         : i1(),i2()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& a2
         ) : i1(a1), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i1(other.i1), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& a2
         ) 
     {
             i1 = a1;
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     type2_
     >::i0;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     type2_
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     type2 i2;
 
     LITE_INLINE pack() 
         : i0(),i2()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& a2
         ) : i0(a0), i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i0(other.i0), i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i0 = other.i0;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& a2
         ) 
     {
             i0 = a0;
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     type2_
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     type2 i2;
 
     LITE_INLINE pack() 
         : i2()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& a2
         ) : i2(a2) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i2(other.i2)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i2 = other.i2;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& a2
         ) 
     {
             i2 = a2;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     type2_
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_
     >
 class pack<
     type0_,
     type1_,
     constant<type2_, value2_>
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
     static const type2 i2 = value2_;
 
     LITE_INLINE pack() 
         : i0(),i1()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1,
         const type2& 
         ) : i0(a0), i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i0(other.i0), i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1,
         const type2& 
         ) 
     {
             i0 = a0;
             i1 = a1;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_,
     typename type2_, type2_ value2_
     >
 const type2_ pack<
     type0_,
     type1_,
     constant<type2_, value2_>
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_
     >
 class pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_const2 = true;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
     static const type2 i2 = value2_;
 
     LITE_INLINE pack() 
         : i1()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1,
         const type2& 
         ) : i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1,
         const type2& 
         ) 
     {
             i1 = a1;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_,
     typename type2_, type2_ value2_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     type1_,
     constant<type2_, value2_>
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 class pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
 
     LITE_INLINE pack() 
         : i0()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& ,
         const type2& 
         ) : i0(a0) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) : i0(other.i0)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& ,
         const type2& 
         ) 
     {
             i0 = a0;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >::i1;
 
 template<
     typename type0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 const type2_ pack<
     type0_,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >
 {
 public:
     static const int n = 3;
 
     typedef type0_ type0;
     typedef type1_ type1;
     typedef type2_ type2;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_const2 = true;
     static const bool is_all_const = true;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
     static const type2 i2 = value2_;
 
     LITE_INLINE pack() 
              {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& ,
         const type2& 
         )  {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& )     {}
 
     LITE_INLINE pack& 
     operator= (const pack& ) 
     {
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ ,
         typename other_type2_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_,
         other_type2_
         >& ) 
     {
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& ,
         const type2& 
         ) 
     {
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >::i1;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_,
     typename type2_, type2_ value2_
     >
 const type2_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>,
     constant<type2_, value2_>
     >::i2;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_
     >
 class pack<
     type0_,
     type1_
     >
 {
 public:
     static const int n = 2;
 
     typedef type0_ type0;
     typedef type1_ type1;
 
     static const bool is_const0 = false;
     static const bool is_const1 = false;
     static const bool is_all_const = false;
     type0 i0;
     type1 i1;
 
     LITE_INLINE pack() 
         : i0(),i1()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& a1
         ) : i0(a0), i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_
         >& other) : i0(other.i0), i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_
         >& other) 
     {
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& a1
         ) 
     {
             i0 = a0;
             i1 = a1;
     }
 };
 
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_
     >
 class pack<
     constant<type0_, value0_>,
     type1_
     >
 {
 public:
     static const int n = 2;
 
     typedef type0_ type0;
     typedef type1_ type1;
 
     static const bool is_const0 = true;
     static const bool is_const1 = false;
     static const bool is_all_const = false;
     static const type0 i0 = value0_;
     type1 i1;
 
     LITE_INLINE pack() 
         : i1()    {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& a1
         ) : i1(a1) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_
         >& other) : i1(other.i1)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_
         >& other) 
     {
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& a1
         ) 
     {
             i1 = a1;
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     type1_
     >::i0;
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_, type1_ value1_
     >
 class pack<
     type0_,
     constant<type1_, value1_>
     >
 {
 public:
     static const int n = 2;
 
     typedef type0_ type0;
     typedef type1_ type1;
 
     static const bool is_const0 = false;
     static const bool is_const1 = true;
     static const bool is_all_const = false;
     type0 i0;
     static const type1 i1 = value1_;
 
     LITE_INLINE pack() 
         : i0()    {}
     
     LITE_INLINE pack(const type0& a0)
         : i0(a0) 
      {}
 
     LITE_INLINE pack(
         const type0& a0,
         const type1& 
         ) : i0(a0) {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_
         >& other) : i0(other.i0)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_
         >& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0,
         const type1& 
         ) 
     {
             i0 = a0;
     }
 };
 
 
 template<
     typename type0_,
     typename type1_, type1_ value1_
     >
 const type1_ pack<
     type0_,
     constant<type1_, value1_>
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_
     >
 class pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>
     >
 {
 public:
     static const int n = 2;
 
     typedef type0_ type0;
     typedef type1_ type1;
 
     static const bool is_const0 = true;
     static const bool is_const1 = true;
     static const bool is_all_const = true;
     static const type0 i0 = value0_;
     static const type1 i1 = value1_;
 
     LITE_INLINE pack() 
              {}
     
     LITE_INLINE pack(const type0& )
      {}
 
     LITE_INLINE pack(
         const type0& ,
         const type1& 
         )  {}
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_,
         other_type1_
         >& )     {}
 
     LITE_INLINE pack& 
     operator= (const pack& ) 
     {
         return *this;
     }
 
     template<
         typename other_type0_ ,
         typename other_type1_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_,
         other_type1_
         >& ) 
     {
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& ,
         const type1& 
         ) 
     {
     }
 };
 
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_
     >
 const type0_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>
     >::i0;
 
 template<
     typename type0_, type0_ value0_,
     typename type1_, type1_ value1_
     >
 const type1_ pack<
     constant<type0_, value0_>,
     constant<type1_, value1_>
     >::i1;
 
 /***********************************************************************************************************/
 template<
     typename type0_
     >
 class pack<
     type0_
     >
 {
 public:
     static const int n = 1;
 
     typedef type0_ type0;
 
     static const bool is_const0 = false;
     static const bool is_all_const = false;
     type0 i0;
 
     LITE_INLINE pack() 
         : i0()    {}
     
 
     LITE_INLINE pack(
         const type0& a0
         ) : i0(a0) {}
 
     template<
         typename other_type0_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_
         >& other) : i0(other.i0)    {}
 
     LITE_INLINE pack& 
     operator= (const pack& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     template<
         typename other_type0_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_
         >& other) 
     {
         i0 = other.i0;
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& a0
         ) 
     {
             i0 = a0;
     }
 };
 
 
 /***********************************************************************************************************/
 template<
     typename type0_, type0_ value0_
     >
 class pack<
     constant<type0_, value0_>
     >
 {
 public:
     static const int n = 1;
 
     typedef type0_ type0;
 
     static const bool is_const0 = true;
     static const bool is_all_const = true;
     static const type0 i0 = value0_;
 
     LITE_INLINE pack() 
              {}
     
 
     LITE_INLINE pack(
         const type0& 
         )  {}
 
     template<
         typename other_type0_ 
     >
     LITE_INLINE pack(const pack<
         other_type0_
         >& )     {}
 
     LITE_INLINE pack& 
     operator= (const pack& ) 
     {
         return *this;
     }
 
     template<
         typename other_type0_ 
     >
     LITE_INLINE pack&  
     operator=(const pack<
         other_type0_
         >& ) 
     {
         return *this;
     }
 
     LITE_INLINE void set(
         const type0& 
         ) 
     {
     }
 };
 
 
 template<
     typename type0_, type0_ value0_
     >
 const type0_ pack<
     constant<type0_, value0_>
     >::i0;
 
 /***********************************************************************************************************/
 
 
 /***********************************************************************************************************/
 
 template<>
 class pack<>
 {
 public:
     static const int n = 0;
 
     LITE_INLINE pack() {}
 
     LITE_INLINE pack(const pack&) {}
 
     LITE_INLINE pack& operator= (const pack&) 
     { return *this; }
 
     LITE_INLINE void set() 
     {}
 };
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* sub_pack ************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename pack_type_, bool keep0_ ..., bool keepN_>
 class sub_pack
 {
 public:
     typedef pack_type_ input_pack_type; 
 
     typedef pack<...> type; 
 
     static void set(type& res, input_pack_type::type0 a0, ..., input_pack_type::typeN aN);
 
     static void set(type& res, const input_pack_type& org);
 };
 
 #else // DOCUMENTATION_ONLY
 
 
 template<
     >
 class sub_pack<
     pack<
     >
     >
 {
 public:
     typedef pack<
     > input_pack_type;
 
     typedef pack<
     > type;
 
     static LITE_INLINE void set(
         type& res
         ) 
     {
         res.set();
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set();
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_
     >
 class sub_pack<
     pack<
         type0_
     >,
     false
     >
 {
 public:
     typedef pack<
         type0_
     > input_pack_type;
 
     typedef pack<
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& 
         ) 
     {
         res.set();
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set();
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_
     >
 class sub_pack<
     pack<
         type0_
     >,
     true
     >
 {
 public:
     typedef pack<
         type0_
     > input_pack_type;
 
     typedef pack<
         type0_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0
         ) 
     {
         res.set(a0);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_
     >
 class sub_pack<
     pack<
         type0_,
         type1_
     >,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_
     > input_pack_type;
 
     typedef pack<
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& 
         ) 
     {
         res.set();
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set();
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_
     >
 class sub_pack<
     pack<
         type0_,
         type1_
     >,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_
     > input_pack_type;
 
     typedef pack<
         type0_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& 
         ) 
     {
         res.set(a0);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_
     >
 class sub_pack<
     pack<
         type0_,
         type1_
     >,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_
     > input_pack_type;
 
     typedef pack<
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1
         ) 
     {
         res.set(a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_
     >
 class sub_pack<
     pack<
         type0_,
         type1_
     >,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1
         ) 
     {
         res.set(a0,a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     false,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& 
         ) 
     {
         res.set();
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set();
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     true,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type0_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& 
         ) 
     {
         res.set(a0);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     false,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& 
         ) 
     {
         res.set(a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     true,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& 
         ) 
     {
         res.set(a0,a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     false,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2
         ) 
     {
         res.set(a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     true,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2
         ) 
     {
         res.set(a0,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     false,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type1_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2
         ) 
     {
         res.set(a1,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_
     >,
     true,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2
         ) 
     {
         res.set(a0,a1,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     false,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set();
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set();
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     false,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a0);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     true,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     true,
     false,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a0,a1);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     false,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     false,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a0,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     true,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type1_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a1,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     true,
     true,
     false
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& 
         ) 
     {
         res.set(a0,a1,a2);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1,org.i2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     false,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     false,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a0,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     true,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type1_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a1,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     true,
     false,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& ,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a0,a1,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     false,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type2_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a2,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i2,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     false,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type2_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& ,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a0,a2,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i2,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     false,
     true,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type1_,
         type2_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& ,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a1,a2,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i1,org.i2,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 class sub_pack<
     pack<
         type0_,
         type1_,
         type2_,
         type3_
     >,
     true,
     true,
     true,
     true
     >
 {
 public:
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > input_pack_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_,
         type3_
     > type;
 
     static LITE_INLINE void set(
         type& res,
         const typename input_pack_type::type0& a0,
         const typename input_pack_type::type1& a1,
         const typename input_pack_type::type2& a2,
         const typename input_pack_type::type3& a3
         ) 
     {
         res.set(a0,a1,a2,a3);
     }
 
     static LITE_INLINE void set(type& res, const input_pack_type& org)
     {
         res.set(org.i0,org.i1,org.i2,org.i3);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* get_type ************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<int index_, typename type_>
 struct get_type
 {
     typedef ... type; 
 };
 
 #else // DOCUMENTATION_ONLY
 
 
 template<int index_, typename type_>
 struct get_type;
 
 template<typename type_>
 struct get_type<0, type_>
 {
     typedef typename type_::type0 type;
 };
 template<typename type_>
 struct get_type<1, type_>
 {
     typedef typename type_::type1 type;
 };
 template<typename type_>
 struct get_type<2, type_>
 {
     typedef typename type_::type2 type;
 };
 template<typename type_>
 struct get_type<3, type_>
 {
     typedef typename type_::type3 type;
 };
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* get *****************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<int index_, typename type_>
 typename get_type<index_, type_>::type get(const type_& a);
 
 #else // DOCUMENTATION_ONLY
 
 template<int index_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<index_==0, typename get_type<index_, type_>::type>::type 
 get(const type_& a)
 {
     LITE_ARRAY_USE(a);
     return a.i0;
 };
 
 template<int index_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<index_==1, typename get_type<index_, type_>::type>::type 
 get(const type_& a)
 {
     LITE_ARRAY_USE(a);
     return a.i1;
 };
 
 template<int index_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<index_==2, typename get_type<index_, type_>::type>::type 
 get(const type_& a)
 {
     LITE_ARRAY_USE(a);
     return a.i2;
 };
 
 template<int index_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<index_==3, typename get_type<index_, type_>::type>::type 
 get(const type_& a)
 {
     LITE_ARRAY_USE(a);
     return a.i3;
 };
 
 
 #endif // DOCUMENTATION_ONLY
 /***********************************************************************************************************/
 /* set *****************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<int index_, typename type_,  typename value_type_>
 void set(type_& a, const value_type_& v);
 
 #else // DOCUMENTATION_ONLY
 
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==0 && type_::is_const0>::type 
 set(type_&, const value_type_&)
 {}
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==0 && !type_::is_const0>::type 
 set(type_& a, const value_type_& v)
 {
     a.i0 = v;
 }
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==1 && type_::is_const1>::type 
 set(type_&, const value_type_&)
 {}
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==1 && !type_::is_const1>::type 
 set(type_& a, const value_type_& v)
 {
     a.i1 = v;
 }
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==2 && type_::is_const2>::type 
 set(type_&, const value_type_&)
 {}
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==2 && !type_::is_const2>::type 
 set(type_& a, const value_type_& v)
 {
     a.i2 = v;
 }
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==3 && type_::is_const3>::type 
 set(type_&, const value_type_&)
 {}
 
 template<int index_, typename type_,  typename value_type_>
 LITE_INLINE 
 typename detail::enable_if<index_==3 && !type_::is_const3>::type 
 set(type_& a, const value_type_& v)
 {
     a.i3 = v;
 }
 
 #endif // DOCUMENTATION_ONLY
 /***********************************************************************************************************/
 /* pack, operator< *****************************************************************************************/
 /***********************************************************************************************************/
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator<(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 #endif // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator<(const pack<>&, const pack<>&)
 { 
     return false;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator<(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return a.i0<b.i0;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator<(
     const pack<l_type0_, l_type1_>& a,
     const pack<r_type0_, r_type1_>& b)
 {
     return a.i0<b.i0 && a.i1<b.i1;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator<(
     const pack<l_type0_, l_type1_, l_type2_>& a,
     const pack<r_type0_, r_type1_, r_type2_>& b)
 {
     return a.i0<b.i0 && a.i1<b.i1 && a.i2<b.i2;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 /***********************************************************************************************************/
 /* pack, operator<= ****************************************************************************************/
 /***********************************************************************************************************/
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator<=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 #endif // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator<=(const pack<>&, const pack<>&)
 { 
     return true;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator<=(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return a.i0<=b.i0;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator<=(
     const pack<l_type0_, l_type1_>& a,
     const pack<r_type0_, r_type1_>& b)
 {
     return a.i0<=b.i0 && a.i1<=b.i1;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator<=(
     const pack<l_type0_, l_type1_, l_type2_>& a,
     const pack<r_type0_, r_type1_, r_type2_>& b)
 {
     return a.i0<=b.i0 && a.i1<=b.i1 && a.i2<=b.i2;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 /***********************************************************************************************************/
 /* pack, operator== ****************************************************************************************/
 /***********************************************************************************************************/
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator==(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 #endif // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator==(const pack<>&, const pack<>&)
 { 
     return true;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator==(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return a.i0==b.i0;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator==(
     const pack<l_type0_, l_type1_>& a,
     const pack<r_type0_, r_type1_>& b)
 {
     return a.i0==b.i0 && a.i1==b.i1;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator==(
     const pack<l_type0_, l_type1_, l_type2_>& a,
     const pack<r_type0_, r_type1_, r_type2_>& b)
 {
     return a.i0==b.i0 && a.i1==b.i1 && a.i2==b.i2;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 /***********************************************************************************************************/
 /* pack, operator>= ****************************************************************************************/
 /***********************************************************************************************************/
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator>=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 #endif // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator>=(const pack<>&, const pack<>&)
 { 
     return true;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator>=(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return a.i0>=b.i0;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator>=(
     const pack<l_type0_, l_type1_>& a,
     const pack<r_type0_, r_type1_>& b)
 {
     return a.i0>=b.i0 && a.i1>=b.i1;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator>=(
     const pack<l_type0_, l_type1_, l_type2_>& a,
     const pack<r_type0_, r_type1_, r_type2_>& b)
 {
     return a.i0>=b.i0 && a.i1>=b.i1 && a.i2>=b.i2;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 /***********************************************************************************************************/
 /* pack, operator> *****************************************************************************************/
 /***********************************************************************************************************/
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator>(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 #endif // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator>(const pack<>&, const pack<>&)
 { 
     return false;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator>(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return a.i0>b.i0;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator>(
     const pack<l_type0_, l_type1_>& a,
     const pack<r_type0_, r_type1_>& b)
 {
     return a.i0>b.i0 && a.i1>b.i1;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator>(
     const pack<l_type0_, l_type1_, l_type2_>& a,
     const pack<r_type0_, r_type1_, r_type2_>& b)
 {
     return a.i0>b.i0 && a.i1>b.i1 && a.i2>b.i2;
     LITE_ARRAY_USE(a);
     LITE_ARRAY_USE(b);
 }
 
 
 /***********************************************************************************************************/
 /* pack, operator!= ****************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
 bool operator!=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
 
 #else // DOCUMENTATION_ONLY
 
 LITE_INLINE
 bool operator!=(const pack<>&, const pack<>&)
 { 
     return false;
 }
 
 template<
     typename l_type0_,
     typename r_type0_ 
 >
 LITE_INLINE
 bool operator!=(
     const pack<l_type0_>& a,
     const pack<r_type0_>& b)
 {
     return !(a==b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename r_type0_, 
     typename r_type1_ 
 >
 LITE_INLINE
 bool operator!=(
     const pack<l_type0_,l_type1_>& a,
     const pack<r_type0_,r_type1_>& b)
 {
     return !(a==b);
 }
 
 template<
     typename l_type0_,
     typename l_type1_,
     typename l_type2_,
     typename r_type0_, 
     typename r_type1_, 
     typename r_type2_ 
 >
 LITE_INLINE
 bool operator!=(
     const pack<l_type0_,l_type1_,l_type2_>& a,
     const pack<r_type0_,r_type1_,r_type2_>& b)
 {
     return !(a==b);
 }
 
 
 #endif // !DOCUMENTATION_ONLY
 /***********************************************************************************************************/
 /* pack io, operator<< *************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename char_type_, typename traits_type_, typename type0_, ..., typename typeN_>
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<type0_, ..., typeN_>& p);
 
 #else // DOCUMENTATION_ONLY
 
 
 template<
     typename char_type_,
     typename traits_type_
     >
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<>& p)
 {
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
 
     if (punct)
         os << ']';
     return os;
 
     LITE_ARRAY_USE(p);
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_
     >
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<type0_>& p)
 {
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
     os.width(width); os << p.i0;
 
     if (punct)
         os << ']';
     return os;
 
     LITE_ARRAY_USE(p);
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_
     >
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<type0_,type1_>& p)
 {
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
     os.width(width); os << p.i0; os << ' ';
     os.width(width); os << p.i1;
 
     if (punct)
         os << ']';
     return os;
 
     LITE_ARRAY_USE(p);
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<type0_,type1_,type2_>& p)
 {
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
     os.width(width); os << p.i0; os << ' ';
     os.width(width); os << p.i1; os << ' ';
     os.width(width); os << p.i2;
 
     if (punct)
         os << ']';
     return os;
 
     LITE_ARRAY_USE(p);
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 std::basic_ostream<char_type_, traits_type_>&
 operator<<(
     std::basic_ostream<char_type_, traits_type_>& os, 
     const pack<type0_,type1_,type2_,type3_>& p)
 {
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
     os.width(width); os << p.i0; os << ' ';
     os.width(width); os << p.i1; os << ' ';
     os.width(width); os << p.i2; os << ' ';
     os.width(width); os << p.i3;
 
     if (punct)
         os << ']';
     return os;
 
     LITE_ARRAY_USE(p);
 }
 
 
 #endif // !DOCUMENTATION_ONLY
 /***********************************************************************************************************/
 /* pack io, operator>> *************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename char_type_, typename traits_type_, typename type0_, ..., typename typeN_>
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_istream<char_type_, traits_type_>& is, 
     pack<type0_, ..., typeN_>& p);
 
 #else // DOCUMENTATION_ONLY
 
 
 template<
     typename char_type_,
     typename traits_type_
     >
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_ostream<char_type_, traits_type_>& is, 
     pack<>& p)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     if (!fancy)
         is.putback(ch);
 
 
     ch = char_type_();
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return is;
     }
     
     p.set();
     return is;
     LITE_ARRAY_USE(p);
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_
     >
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_ostream<char_type_, traits_type_>& is, 
     pack<type0_>& p)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     if (!fancy)
         is.putback(ch);
 
     type0_ i0; is >> i0;
 
     ch = char_type_();
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return is;
     }
     
     p.set(i0);
     return is;
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_
     >
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_ostream<char_type_, traits_type_>& is, 
     pack<type0_,type1_>& p)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     if (!fancy)
         is.putback(ch);
 
     type0_ i0; is >> i0;
     type1_ i1; is >> i1;
 
     ch = char_type_();
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return is;
     }
     
     p.set(i0, i1);
     return is;
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_ostream<char_type_, traits_type_>& is, 
     pack<type0_,type1_,type2_>& p)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     if (!fancy)
         is.putback(ch);
 
     type0_ i0; is >> i0;
     type1_ i1; is >> i1;
     type2_ i2; is >> i2;
 
     ch = char_type_();
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return is;
     }
     
     p.set(i0, i1, i2);
     return is;
 }
 
 
 template<
     typename char_type_,
     typename traits_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename type3_
     >
 std::basic_istream<char_type_, traits_type_>&
 operator>>(
     std::basic_ostream<char_type_, traits_type_>& is, 
     pack<type0_,type1_,type2_,type3_>& p)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     if (!fancy)
         is.putback(ch);
 
     type0_ i0; is >> i0;
     type1_ i1; is >> i1;
     type2_ i2; is >> i2;
     type3_ i3; is >> i3;
 
     ch = char_type_();
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return is;
     }
     
     p.set(i0, i1, i2, i3);
     return is;
 }
 
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* error checking functions ********************************************************************************/
 /***********************************************************************************************************/
 
 template<typename left_size_type_, typename right_size_type_>
 void lite_array_size_check(const left_size_type_& a, const right_size_type_& b, const std::string& msg)
 {
     if (a != b)
         throw size_mismatch_error(msg);
 }
 
 } // namespace lite
 
 /***********************************************************************************************************/
 /* iterator_traits<pack<...> > *****************************************************************************/
 /***********************************************************************************************************/
 
 namespace std
 {
     template<
             typename type0_,
             typename type1_,
             typename type2_,
             typename type3_
             >
     struct iterator_traits<lite::pack<
             type0_,
             type1_,
             type2_,
             type3_
         > >
         : public iterator_traits<type0_>
     {};
 } // namespace std
 
 namespace lite
 { 
 
 /***********************************************************************************************************/
 /* s_iterator **********************************************************************************************/
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* s_iterator, at() ****************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename iter_type_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_
     > >::reference 
 at(const pack<
     iter_type_
     >& it
     )
 {
     return *(it.i0);
 }
 template<
     typename iter_type_,
     typename ind_type0_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_
     >& it
     )
 {
     return *(it.i0);
 }
 template<
     typename iter_type_,
     typename ind_type0_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_
     >& it,
     int ind0
     )
 {
     return *(it.i0+ind0*it.i1);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     >& it
     )
 {
     return *(it.i0);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     >& it,
     int ind0
     )
 {
     return *(it.i0+ind0*it.i2);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_
     >& it,
     int ind0,
     int ind1
     )
 {
     return *(it.i0+ind0*it.i1+ind1*it.i2);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it
     )
 {
     return *(it.i0);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int ind0
     )
 {
     return *(it.i0+ind0*it.i3);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int ind0,
     int ind1
     )
 {
     return *(it.i0+ind0*it.i2+ind1*it.i3);
 }
 template<
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename std::iterator_traits<pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     > >::reference 
 at(const pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int ind0,
     int ind1,
     int ind2
     )
 {
     return *(it.i0+ind0*it.i1+ind1*it.i2+ind2*it.i3);
 }
 
 /***********************************************************************************************************/
 /* s_iterator, inc() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==0, void>::type 
 inc(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 += it.i1;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==1, void>::type 
 inc(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 += it.i2;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==2, void>::type 
 inc(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 += it.i3;
 }
 
 
 /***********************************************************************************************************/
 /* s_iterator, dec() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==0, void>::type 
 dec(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 -= it.i1;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==1, void>::type 
 dec(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 -= it.i2;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==2, void>::type 
 dec(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it)
 {
     it.i0 -= it.i3;
 }
 
 
 /***********************************************************************************************************/
 /* s_iterator, shift() *************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==0, void>::type 
 shift(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int diff)
 {
     it.i0 += diff*it.i1;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==1, void>::type 
 shift(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int diff)
 {
     it.i0 += diff*it.i2;
 }
 
 template<
     int dim_, 
     typename iter_type_,
     typename ind_type0_,
     typename ind_type1_,
     typename ind_type2_
     >
 LITE_INLINE 
 typename detail::enable_if<dim_==2, void>::type 
 shift(pack<
     iter_type_,
     ind_type0_,
     ind_type1_,
     ind_type2_
     >& it,
     int diff)
 {
     it.i0 += diff*it.i3;
 }
 
 
 /***********************************************************************************************************/
 /* c_iterator **********************************************************************************************/
 /***********************************************************************************************************/
 
 template<class value_type_>
 class c_iterator
 {
 public:
     typedef std::random_access_iterator_tag iterator_category; 
     typedef value_type_ value_type;
     typedef ptrdiff_t difference_type;
     typedef const value_type_* pointer;
     typedef const value_type_& reference;
 
     LITE_INLINE c_iterator() {}
 
     LITE_INLINE c_iterator(const value_type& value) : value(value) {}
 
     LITE_INLINE c_iterator(const c_iterator& other) : value(other.value) {}
 
     template<class other_value_type_>
     LITE_INLINE c_iterator(const c_iterator<other_value_type_>& other) : value(other.value) {}
 
     LITE_INLINE c_iterator& operator=(const c_iterator& other) 
     {
         value = other.value;
         return *this;
     }
 
     template<class other_value_type_>
     LITE_INLINE c_iterator& operator=(const c_iterator<other_value_type_>& other)
     {
         value = other.value;
         return *this;
     }
 
     value_type value;
 };
 
 template<class value_type_>
 LITE_INLINE c_iterator<value_type_> 
 make_c_iterator(const value_type_& val)
 {
     return c_iterator<value_type_>(val);
 }
 
 /***********************************************************************************************************/
 /* c_iterator, at() ****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_>
 LITE_INLINE 
 typename std::iterator_traits<c_iterator<value_type_> >::reference
 at(const c_iterator<value_type_>& it )
 {
     return it.value;
 }
 template<typename value_type_>
 LITE_INLINE 
 typename std::iterator_traits<c_iterator<value_type_> >::reference
 at(const c_iterator<value_type_>& it, int )
 {
     return it.value;
 }
 template<typename value_type_>
 LITE_INLINE 
 typename std::iterator_traits<c_iterator<value_type_> >::reference
 at(const c_iterator<value_type_>& it, int , int )
 {
     return it.value;
 }
 template<typename value_type_>
 LITE_INLINE 
 typename std::iterator_traits<c_iterator<value_type_> >::reference
 at(const c_iterator<value_type_>& it, int , int , int )
 {
     return it.value;
 }
 
 /***********************************************************************************************************/
 /* c_iterator, inc() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename value_type_>
 LITE_INLINE void inc(c_iterator<value_type_>&) {}
 
 /***********************************************************************************************************/
 /* c_iterator, dec() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename value_type_>
 LITE_INLINE void dec(c_iterator<value_type_>&) {}
 
 /***********************************************************************************************************/
 /* c_iterator, shift() *************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename value_type_>
 LITE_INLINE void shift(c_iterator<value_type_>&, int) {}
 
 /***********************************************************************************************************/
 /* u_iterator **********************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename base_iter_type_, typename func_type_, bool is_static_ =true>
 class u_iterator
 {
 public:
     typedef base_iter_type_ base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = is_static_;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE u_iterator();
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const other_base_iter_type_& base_iter);
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const other_base_iter_type_& base_iter, const function_type& func);
 
     LITE_INLINE u_iterator(const u_iterator& other);
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, is_static_>& other);
 
     LITE_INLINE u_iterator& operator=(const u_iterator& other);
 
     template<typename other_base_iter_type_>
     LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, is_static_>& other);
 
     base_iterator_type base_iterator;
 
     function_type function;
 };
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* u_iterator - unary iterator (static) ********************************************************************/
 /***********************************************************************************************************/
 
 #ifndef DOCUMENTATION_ONLY
 
 template<typename base_iter_type_, typename func_type_>
 class u_iterator<base_iter_type_, func_type_, true>
 {
 public:
     typedef base_iter_type_ base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = true;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE u_iterator() {}
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const other_base_iter_type_& base_iter)
         : base_iterator(base_iter) {}
 
     LITE_INLINE u_iterator(const u_iterator& other)
         : base_iterator(other.base_iterator) {}
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, true>& other)
         : base_iterator(other.base_iterator) {}
 
     LITE_INLINE u_iterator& operator=(const u_iterator& other)
     {
         base_iterator = other.base_iterator;
         return *this;
     }
 
     template<typename other_base_iter_type_>
     LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, true>& other)
     {
         base_iterator = other.base_iterator;
         return *this;
     }
 
     base_iterator_type base_iterator;
     static function_type function;
 };
 
 template<typename base_iter_type_, typename func_type_>
 typename u_iterator<base_iter_type_, func_type_, true>::function_type
 u_iterator<base_iter_type_, func_type_, true>::function;
 
 #endif // !DOCUMENTATION_ONLY
 
 template<typename func_type_, typename base_iter_type_>
 LITE_INLINE u_iterator<base_iter_type_, func_type_, true>
 make_u_iterator(const base_iter_type_& it)
 {
     return u_iterator<base_iter_type_, func_type_, true>(it);
 }
 
 /***********************************************************************************************************/
 /* u_iterator - unary iterator (non-static) ****************************************************************/
 /***********************************************************************************************************/
 
 #ifndef DOCUMENTATION_ONLY
 
 template<typename base_iter_type_, typename func_type_>
 class u_iterator<base_iter_type_, func_type_, false>
 {
 public:
     typedef base_iter_type_ base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = false;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE u_iterator() {}
 
     template<class other_base_iter_type_>
     LITE_INLINE u_iterator(const other_base_iter_type_& base_iter, const function_type& func =function_type())
         : base_iterator(base_iter), function(func) {}
 
     LITE_INLINE u_iterator(const u_iterator& other)
         : base_iterator(other.base_iterator), function(other.function) {}
 
     template<typename other_base_iter_type_>
     LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, false>& other)
         : base_iterator(other.base_iterator), function(other.function) {}
 
     LITE_INLINE u_iterator& operator=(const u_iterator& other)
     {
         base_iterator = other.base_iterator;
         function = other.function;
         return *this;
     }
 
     template<typename other_base_iter_type_>
     LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, false>& other)
     {
         base_iterator = other.base_iterator;
         function = other.function;
         return *this;
     }
 
     base_iterator_type base_iterator;
     function_type function;
 };
 
 #endif // !DOCUMENTATION_ONLY
 
 template<typename func_type_, typename base_iter_type_>
 LITE_INLINE u_iterator<base_iter_type_, func_type_, false>
 make_u_iterator(const base_iter_type_& it, const func_type_& func)
 {
     return u_iterator<base_iter_type_, func_type_, false>(it, func);
 }
 
 /***********************************************************************************************************/
 /* u_iterator, at() ****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE 
 typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
 at(const u_iterator<base_iter_type_, func_type_, is_static_>& it
     )
 {
     return it.function(at(it.base_iterator 
     ));
 }
 template<typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE 
 typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
 at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
     int ind0
     )
 {
     return it.function(at(it.base_iterator, 
         ind0
     ));
 }
 template<typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE 
 typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
 at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
     int ind0,
     int ind1
     )
 {
     return it.function(at(it.base_iterator, 
         ind0,
         ind1
     ));
 }
 template<typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE 
 typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
 at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
     int ind0,
     int ind1,
     int ind2
     )
 {
     return it.function(at(it.base_iterator, 
         ind0,
         ind1,
         ind2
     ));
 }
 
 /***********************************************************************************************************/
 /* u_iterator, inc() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE void inc(u_iterator<base_iter_type_, func_type_, is_static_>& it) 
 {
     inc<dim_>(it.base_iterator);
 }
 
 /***********************************************************************************************************/
 /* u_iterator, dec() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE void dec(u_iterator<base_iter_type_, func_type_, is_static_>& it) 
 {
     dec<dim_>(it.base_iterator);
 }
 
 /***********************************************************************************************************/
 /* u_iterator, shift() *************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE void shift(u_iterator<base_iter_type_, func_type_, is_static_>& it, int diff) 
 {
     shift<dim_>(it.base_iterator, diff);
 }
 
 /***********************************************************************************************************/
 /* b_iterator **********************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<
     typename left_base_iterator_type_, 
     typename right_base_iterator_type_, 
     typename func_type_, 
     bool is_static_ =true>
 class b_iterator
 {
 public:
     typedef left_base_iterator_type_ left_base_iterator_type;
     typedef right_base_iterator_type_ right_base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = is_static_;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE b_iterator() {}
 
     
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const other_left_base_iterator_type_& lbase_iter, 
         const other_right_base_iterator_type_& rbase_iter);
 
     LITE_INLINE b_iterator(const b_iterator& other);
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const b_iterator<
             other_left_base_iterator_type_, 
             other_right_base_iterator_type_, 
             func_type_, 
             is_static_>& other);
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const other_left_base_iterator_type_& lbase_iter, 
         const other_right_base_iterator_type_& rbase_iter, 
         const function_type& func);
 
 
     LITE_INLINE b_iterator& operator=(const b_iterator& other);
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator& 
     operator=(const b_iterator<
         other_left_base_iterator_type_, 
         other_right_base_iterator_type_, 
         func_type_, 
         is_static_>& other);
     
     left_base_iterator_type left_base_iterator;
 
     right_base_iterator_type right_base_iterator;
 
     function_type function;
 };
 
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* b_iterator - binary iterator (static) *******************************************************************/
 /***********************************************************************************************************/
 
 #ifndef DOCUMENTATION_ONLY
 
 template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
 class b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
 {
 public:
     typedef left_base_iterator_type_ left_base_iterator_type;
     typedef right_base_iterator_type_ right_base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = true;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE b_iterator() {}
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const other_left_base_iterator_type_& lbase_iter, 
         const other_right_base_iterator_type_& rbase_iter)
         : left_base_iterator(lbase_iter), right_base_iterator(rbase_iter) {}
 
     LITE_INLINE b_iterator(const b_iterator& other)
         : left_base_iterator(other.left_base_iterator), 
         right_base_iterator(other.right_base_iterator)
     {}
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const b_iterator<
             other_left_base_iterator_type_, 
             other_right_base_iterator_type_, 
             func_type_, 
             true>& other)
         : left_base_iterator(other.left_base_iterator), 
         right_base_iterator(other.right_base_iterator)
     {}
 
     LITE_INLINE b_iterator& operator=(const b_iterator& other)
     {
         left_base_iterator = other.left_base_iterator;
         right_base_iterator = other.right_base_iterator;
         return *this;
     }
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator& 
     operator=(const b_iterator<
         other_left_base_iterator_type_, 
         other_right_base_iterator_type_, 
         func_type_, 
         true>& other)
     {
         left_base_iterator = other.left_base_iterator;
         right_base_iterator = other.right_base_iterator;
         return *this;
     }
     
     left_base_iterator_type left_base_iterator;
     right_base_iterator_type right_base_iterator;
     static function_type function;
 };
 
 template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
 typename b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>::function_type
 b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>::function;
 
 #endif // !DOCUMENTATION_ONLY
 
 template<typename func_type_, typename left_base_iterator_type_, typename right_base_iterator_type_>
 LITE_INLINE b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
 make_b_iterator(
     const left_base_iterator_type_& left_it, 
     const right_base_iterator_type_& right_it)
 {
     return b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
         (left_it, right_it);
 }
 
 /***********************************************************************************************************/
 /* b_iterator - binary iterator (non-static) ***************************************************************/
 /***********************************************************************************************************/
 
 #ifndef DOCUMENTATION_ONLY
 
 template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
 class b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
 {
 public:
     typedef left_base_iterator_type_ left_base_iterator_type;
     typedef right_base_iterator_type_ right_base_iterator_type;
     typedef func_type_ function_type;
     static const bool is_static = false;
 
     typedef std::random_access_iterator_tag iterator_category;
     typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
     typedef ptrdiff_t difference_type;
     typedef typename func_type_::result_type reference;
     typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;
 
     LITE_INLINE b_iterator() {}
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const other_left_base_iterator_type_& lbase_iter, 
         const other_right_base_iterator_type_& rbase_iter, 
         const function_type& func = function_type())
         : left_base_iterator(lbase_iter), right_base_iterator(rbase_iter), function(func) {}
 
     LITE_INLINE b_iterator(const b_iterator& other)
         : left_base_iterator(other.left_base_iterator), 
         right_base_iterator(other.right_base_iterator), 
         function(other.function) 
     {}
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator(
         const b_iterator<
             other_left_base_iterator_type_, 
             other_right_base_iterator_type_, 
             func_type_, 
             false>& other)
         : left_base_iterator(other.left_base_iterator), 
         right_base_iterator(other.right_base_iterator), 
         function(other.function) 
     {}
 
     LITE_INLINE b_iterator& operator=(const b_iterator& other)
     {
         left_base_iterator = other.left_base_iterator;
         right_base_iterator = other.right_base_iterator;
         function = other.function;
         return *this;
     }
 
     template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
     LITE_INLINE b_iterator& 
     operator=(const b_iterator<
         other_left_base_iterator_type_, 
         other_right_base_iterator_type_, 
         func_type_, 
         false>& other)
     {
         left_base_iterator = other.left_base_iterator;
         right_base_iterator = other.right_base_iterator;
         function = other.function;
         return *this;
     }
     
     left_base_iterator_type left_base_iterator;
     right_base_iterator_type right_base_iterator;
     function_type function;
 };
 
 #endif // DOCUMENTATION_ONLY
 
 template<typename func_type_, typename left_base_iterator_type_, typename right_base_iterator_type_>
 LITE_INLINE b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
 make_b_iterator(
     const left_base_iterator_type_& left_it, 
     const right_base_iterator_type_& right_it, 
     const func_type_& func)
 {
     return b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
         (left_it, right_it, func);
 }
 
 /***********************************************************************************************************/
 /* b_iterator, at() ****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE
 typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
 at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it
     )
 {
     return it.function(
         at(it.left_base_iterator 
         ),
         at(it.right_base_iterator 
         )
     );
 }
 template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE
 typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
 at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
     int ind0
     )
 {
     return it.function(
         at(it.left_base_iterator, 
         ind0
         ),
         at(it.right_base_iterator, 
         ind0
         )
     );
 }
 template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE
 typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
 at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
     int ind0,
     int ind1
     )
 {
     return it.function(
         at(it.left_base_iterator, 
         ind0,
         ind1
         ),
         at(it.right_base_iterator, 
         ind0,
         ind1
         )
     );
 }
 template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
 LITE_INLINE
 typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
 at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
     int ind0,
     int ind1,
     int ind2
     )
 {
     return it.function(
         at(it.left_base_iterator, 
         ind0,
         ind1,
         ind2
         ),
         at(it.right_base_iterator, 
         ind0,
         ind1,
         ind2
         )
     );
 }
 
 /***********************************************************************************************************/
 /* b_iterator, inc() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     bool is_static_>
 LITE_INLINE void inc(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it) 
 {
     inc<dim_>(it.left_base_iterator);
     inc<dim_>(it.right_base_iterator);
 }
 
 /***********************************************************************************************************/
 /* b_iterator, dec() ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     bool is_static_>
 LITE_INLINE void dec(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it) 
 {
     dec<dim_>(it.left_base_iterator);
     dec<dim_>(it.right_base_iterator);
 }
 
 /***********************************************************************************************************/
 /* b_iterator, shift() *************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     int dim_, 
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     bool is_static_>
 LITE_INLINE 
 void shift(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it, int diff) 
 {
     shift<dim_>(it.left_base_iterator, diff);
     shift<dim_>(it.right_base_iterator, diff);
 }
 
 /***********************************************************************************************************/
 /* size_transformer ****************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename transform_type_, typename input_size_type_>
 struct size_transformer
 {
 public:
     typedef ??? size_type;
 
     static void transform(const input_size_type_& org, size_type& res);
 
     static void transform(const transform_type& trans, const input_size_type_& org, size_type& res);
 };
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* iterator_transformer ************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename transform_type_, typename input_iterator_type_, typename input_size_type_>
 struct iterator_transformer
 {
 public:
     typedef ??? iterator_type;
 
     static void transform(
         const input_iterator_type& org, 
         iterator_type& res);
 
     static void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         iterator_type& res);
 
     static void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         const input_size_type_& sz,
         iterator_type& res);
 };
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* iterator_transformer, c_iterator ************************************************************************/
 /***********************************************************************************************************/
 
 template<typename transform_type_, typename value_type_, typename input_size_type_>
 struct iterator_transformer<transform_type_, c_iterator<value_type_>, input_size_type_>
 {
 public:
     typedef c_iterator<value_type_> input_iterator_type;
     typedef input_iterator_type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.value = org.value;
     }
 
     static LITE_INLINE void transform(
         const transform_type_&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.value = org.value;
     }
 
     static LITE_INLINE void transform(
         const transform_type_&, 
         const input_iterator_type& org, 
         const input_size_type_&,
         iterator_type& res)
     {
         res.value = org.value;
     }
 };
 
 /***********************************************************************************************************/
 /* iterator_transformer, u_iterator ************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename transform_type_,
     typename base_iter_type_, 
     typename func_type_, 
     typename input_size_type_>
 struct iterator_transformer<
     transform_type_, 
     u_iterator<base_iter_type_, func_type_, true>, 
     input_size_type_>
 {
 public:
     typedef iterator_transformer<transform_type_, base_iter_type_, input_size_type_> base_transformer;
 
     typedef u_iterator<base_iter_type_, func_type_, true> input_iterator_type;
     typedef u_iterator<typename base_transformer::iterator_type, func_type_, true> iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         base_transformer::transform(org.base_iterator, res.base_iterator);
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         base_transformer::transform(trans, org.base_iterator, res.base_iterator);
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         const input_size_type_& sz,
         iterator_type& res)
     {
         base_transformer::transform(trans, org.base_iterator, sz, res.base_iterator);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename transform_type_,
     typename base_iter_type_, 
     typename func_type_, 
     typename input_size_type_>
 struct iterator_transformer<
     transform_type_, 
     u_iterator<base_iter_type_, func_type_, false>, 
     input_size_type_>
 {
 public:
     typedef iterator_transformer<transform_type_, base_iter_type_, input_size_type_> base_transformer;
 
     typedef u_iterator<base_iter_type_, func_type_, false> input_iterator_type;
     typedef u_iterator<typename base_transformer::iterator_type, func_type_, false> iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         base_transformer::transform(org.base_iterator, res.base_iterator);
         res.function = org.function;
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         base_transformer::transform(trans, org.base_iterator, res.base_iterator);
         res.function = org.function;
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         const input_size_type_& sz,
         iterator_type& res)
     {
         base_transformer::transform(trans, org.base_iterator, sz, res.base_iterator);
         res.function = org.function;
     }
 };
 
 /***********************************************************************************************************/
 /* iterator_transformer, b_iterator ************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename transform_type_,
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     typename input_size_type_>
 struct iterator_transformer<
     transform_type_, 
     b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, true>, 
     input_size_type_>
 {
 public:
     typedef iterator_transformer<transform_type_, left_base_iter_type_, input_size_type_> 
         left_base_transformer;
 
     typedef iterator_transformer<transform_type_, right_base_iter_type_, input_size_type_> 
         right_base_transformer;
 
     typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, true> input_iterator_type;
 
     typedef b_iterator<
         typename left_base_transformer::iterator_type, 
         typename right_base_transformer::iterator_type, 
         func_type_, 
         true> 
         iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         left_base_transformer::transform(org.left_base_iterator, res.left_base_iterator);
         right_base_transformer::transform(org.right_base_iterator, res.right_base_iterator);
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         left_base_transformer::transform(trans, org.left_base_iterator, res.left_base_iterator);
         right_base_transformer::transform(trans, org.right_base_iterator, res.right_base_iterator);
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         const input_size_type_& sz,
         iterator_type& res)
     {
         left_base_transformer::transform(trans, org.left_base_iterator, sz, res.left_base_iterator);
         right_base_transformer::transform(trans, org.right_base_iterator, sz, res.right_base_iterator);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename transform_type_,
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     typename input_size_type_>
 struct iterator_transformer<
     transform_type_, 
     b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, false>, 
     input_size_type_>
 {
 public:
     typedef iterator_transformer<transform_type_, left_base_iter_type_, input_size_type_> 
         left_base_transformer;
 
     typedef iterator_transformer<transform_type_, right_base_iter_type_, input_size_type_> 
         right_base_transformer;
 
     typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, false> input_iterator_type;
 
     typedef b_iterator<
         typename left_base_transformer::iterator_type, 
         typename right_base_transformer::iterator_type, 
         func_type_, 
         false> 
         iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         left_base_transformer::transform(org.left_base_iterator, res.left_base_iterator);
         right_base_transformer::transform(org.right_base_iterator, res.right_base_iterator);
         res.function = org.function;
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         left_base_transformer::transform(trans, org.left_base_iterator, res.left_base_iterator);
         right_base_transformer::transform(trans, org.right_base_iterator, res.right_base_iterator);
         res.function = org.function;
     }
 
     static LITE_INLINE void transform(
         const transform_type_& trans, 
         const input_iterator_type& org, 
         const input_size_type_& sz,
         iterator_type& res)
     {
         left_base_transformer::transform(trans, org.left_base_iterator, sz, res.left_base_iterator);
         right_base_transformer::transform(trans, org.right_base_iterator, sz, res.right_base_iterator);
         res.function = org.function;
     }
 };
 
 /***********************************************************************************************************/
 /* plane ***************************************************************************************************/
 /***********************************************************************************************************/
 
 template<int dim_>
 class plane
 {
 public:
     LITE_INLINE plane(int index =0) : index(index) {}
 
     LITE_INLINE plane(const plane& other) : index(other.index) {}
 
     LITE_INLINE plane& operator=(const plane& other) { index = other.index; return *this; }
 
     int index;
 };
 
 /***********************************************************************************************************/
 /* size_transformer, plane *********************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename type0_
     >
 struct size_transformer<
     plane<0>, 
     pack<
         type0_
     > >
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         type0_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_
     >
 struct size_transformer<
     plane<0>, 
     pack<
         type0_,
         type1_
     > >
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         type0_,
         type1_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         false,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     plane<0>, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         false,
         true,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_
     >
 struct size_transformer<
     plane<1>, 
     pack<
         type0_,
         type1_
     > >
 {
 public:
     typedef plane<1> transform_type;
 
     typedef pack<
         type0_,
         type1_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         true,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     plane<1>, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
 public:
     typedef plane<1> transform_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         true,
         false,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     plane<2>, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
 public:
     typedef plane<2> transform_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
     typedef sub_pack<
         input_size_type,
         true,
         true,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(res, org);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* iterator_transformer, plane *****************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename base_iter_type_,
     typename type0_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<0>, 
     pack<
         base_iter_type_,
         type0_
     >,
     input_size_type_>
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<0>, 
     pack<
         base_iter_type_,
         type0_,
         type1_
     >,
     input_size_type_>
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_,
         type1_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         false,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<0>, 
     pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_>
 {
 public:
     typedef plane<0> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         false,
         true,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<1>, 
     pack<
         base_iter_type_,
         type0_,
         type1_
     >,
     input_size_type_>
 {
 public:
     typedef plane<1> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_,
         type1_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         true,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<1>, 
     pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_>
 {
 public:
     typedef plane<1> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         true,
         false,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_>
 struct iterator_transformer<
     plane<2>, 
     pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_>
 {
 public:
     typedef plane<2> transform_type;
 
     typedef pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         true,
         true,
         false
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
     }
 
     static LITE_INLINE void transform(
         const transform_type& trans, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* diagonal ************************************************************************************************/
 /***********************************************************************************************************/
 
 class diagonal
 {
 public:
     LITE_INLINE diagonal() {}
 
     LITE_INLINE diagonal(const diagonal&) {}
 
     LITE_INLINE diagonal& operator=(const diagonal&) { return *this; }
 };
 
 /***********************************************************************************************************/
 /* size_transformer, diagonal ******************************************************************************/
 /***********************************************************************************************************/
 
 template<>
 struct size_transformer<diagonal, pack<> >
 {
 public:
     typedef diagonal transform_type;
     typedef pack<> input_size_type;
     typedef pack<> size_type;
 
     static LITE_INLINE void transform(const input_size_type&, size_type&)
     {}
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type&, size_type&)
     {}
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_
     >
 struct size_transformer<
     diagonal, 
     pack<
         type0_
     > >
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
 
     static const int min_upto_0_ = n0_;
 
     static const int min_dim_size_ = min_upto_0_;
 
     static const bool has_var_size_ =
         detail::same_type<type0_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
 
     typedef pack<
         type0_
         > input_size_type;
 
 
     typedef pack<
         typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
 
         res.set(min_upto_0);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
 
         res.set(min_upto_0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_
     >
 struct size_transformer<
     diagonal, 
     pack<
         type0_,
         type1_
     > >
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
     static const int n1_ = 
         detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
 
     static const int min_upto_0_ = n0_;
     static const int min_upto_1_ = min_upto_0_ < n1_ ? min_upto_0_ : n1_;
 
     static const int min_dim_size_ = min_upto_1_;
 
     static const bool has_var_size_ =
         detail::same_type<type0_, int>::result||
         detail::same_type<type1_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
 
     typedef pack<
         type0_,
         type1_
         > input_size_type;
 
 
     typedef pack<
         typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
         const int min_upto_1 = min_upto_0 < res.i1 ? min_upto_0 : res.i1;
 
         res.set(min_upto_1);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
         const int min_upto_1 = min_upto_0 < org.i1 ? min_upto_0 : org.i1;
 
         res.set(min_upto_1);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     diagonal, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
     static const int n1_ = 
         detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
     static const int n2_ = 
         detail::type_if<detail::same_type<type2_, int>::result, constant<int, 0>, type2_>::type::value;
 
     static const int min_upto_0_ = n0_;
     static const int min_upto_1_ = min_upto_0_ < n1_ ? min_upto_0_ : n1_;
     static const int min_upto_2_ = min_upto_1_ < n2_ ? min_upto_1_ : n2_;
 
     static const int min_dim_size_ = min_upto_2_;
 
     static const bool has_var_size_ =
         detail::same_type<type0_, int>::result||
         detail::same_type<type1_, int>::result||
         detail::same_type<type2_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
 
     typedef pack<
         typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
         const int min_upto_1 = min_upto_0 < res.i1 ? min_upto_0 : res.i1;
         const int min_upto_2 = min_upto_1 < res.i2 ? min_upto_1 : res.i2;
 
         res.set(min_upto_2);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         const int min_upto_0 = res.i0;
         const int min_upto_1 = min_upto_0 < org.i1 ? min_upto_0 : org.i1;
         const int min_upto_2 = min_upto_1 < org.i2 ? min_upto_1 : org.i2;
 
         res.set(min_upto_2);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* iterator_transformer, diagonal **************************************************************************/
 /***********************************************************************************************************/
 
 
 template<typename base_iter_type_, typename input_size_type_>
 struct iterator_transformer<diagonal, pack<base_iter_type_>, input_size_type_>
 {
 public:
     typedef pack<base_iter_type_> input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef pack<base_iter_type_> iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 
     static LITE_INLINE void transform(
         const diagonal&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 
     static LITE_INLINE void transform(
         const diagonal&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename base_iter_type_,
     typename type0_,
     typename input_size_type_>
 struct iterator_transformer<
     diagonal, 
     pack<
         base_iter_type_,
         type0_
     >,
     input_size_type_>
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
 
     static const int stride_ = n0_;
 
     static const bool has_var_stride_ =
         detail::same_type<type0_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
     typedef pack<
         base_iter_type_,
         type0_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef pack<
         base_iter_type_, 
         typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
         iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1);
     }
 
         static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.set(org.i0, org.i1);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename input_size_type_>
 struct iterator_transformer<
     diagonal, 
     pack<
         base_iter_type_,
         type0_,
         type1_
     >,
     input_size_type_>
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
     static const int n1_ = 
         detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
 
     static const int stride_ = n0_ + n1_;
 
     static const bool has_var_stride_ =
         detail::same_type<type0_, int>::result||
         detail::same_type<type1_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
     typedef pack<
         base_iter_type_,
         type0_,
         type1_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef pack<
         base_iter_type_, 
         typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
         iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1org.i2);
     }
 
         static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1org.i2);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.set(org.i0, org.i1 + org.i2);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_>
 struct iterator_transformer<
     diagonal, 
     pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_>
 {
 private:
     static const int n0_ = 
         detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
     static const int n1_ = 
         detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
     static const int n2_ = 
         detail::type_if<detail::same_type<type2_, int>::result, constant<int, 0>, type2_>::type::value;
 
     static const int stride_ = n0_ + n1_ + n2_;
 
     static const bool has_var_stride_ =
         detail::same_type<type0_, int>::result||
         detail::same_type<type1_, int>::result||
         detail::same_type<type2_, int>::result
         ;
 
 public:
     typedef diagonal transform_type;
     typedef pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
 
     typedef pack<
         base_iter_type_, 
         typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
         iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1org.i2org.i3);
     }
 
         static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.set(org.i0, org.i1org.i2org.i3);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.set(org.i0, org.i1 + org.i2 + org.i3);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* transpose ***********************************************************************************************/
 /***********************************************************************************************************/
 
 class transpose
 {
 public:
     LITE_INLINE transpose() {}
 
     LITE_INLINE transpose(const transpose&) {}
 
     LITE_INLINE transpose& operator=(const transpose&) { return *this; }
 };
 
 /***********************************************************************************************************/
 /* size_transformer, transpose *****************************************************************************/
 /***********************************************************************************************************/
 
 template<>
 struct size_transformer<transpose, pack<> >
 {
 public:
     typedef transpose transform_type;
 
     typedef pack<> input_size_type;
 
     typedef pack<> size_type;
 
     static LITE_INLINE void transform(const input_size_type&, size_type&)
     {}
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type&, size_type&)
     {}
 };
 
 /***********************************************************************************************************/
 
 template<
     typename type0_
     >
 struct size_transformer<
     transpose, 
     pack<
         type0_
     > >
 {
 public:
     typedef transpose transform_type;
 
     typedef pack<
         type0_
         > input_size_type;
 
     typedef pack<
         type0_
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_
     >
 struct size_transformer<
     transpose, 
     pack<
         type0_,
         type1_
     > >
 {
 public:
     typedef transpose transform_type;
 
     typedef pack<
         type0_,
         type1_
         > input_size_type;
 
     typedef pack<
         type1_,
         type0_
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i1);
         set<1>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i1);
         set<1>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     transpose, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
 public:
     typedef transpose transform_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
     typedef pack<
         type2_,
         type1_,
         type0_
         > size_type;
 
     static LITE_INLINE void transform(const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i2);
         set<1>(res, org.i1);
         set<2>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 
     static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
     {
         set<0>(res, org.i2);
         set<1>(res, org.i1);
         set<2>(res, org.i0);
         LITE_ARRAY_USE(org);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* iterator_transformer, transpose *************************************************************************/
 /***********************************************************************************************************/
 
 template<typename base_iter_type_, typename input_size_type_>
 struct iterator_transformer<transpose, pack<base_iter_type_>, input_size_type_>
 {
 public:
     typedef transpose transform_type;
     typedef pack<base_iter_type_> input_iterator_type;
     typedef input_size_type_ input_size_type;
     typedef pack<base_iter_type_> iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.i0 = org.i0;
     }
 };
 
 /***********************************************************************************************************/
 
 
 template<
     typename base_iter_type_,
     typename type0_,
     typename input_size_type_>
 struct iterator_transformer<
     transpose, 
     pack<
         base_iter_type_,
         type0_
     >,
     input_size_type_>
 {
 public:
     typedef transpose transform_type;
     typedef pack<
         base_iter_type_,
         type0_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
     typedef pack<
         base_iter_type_,
         type0_
         > iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i1);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename input_size_type_>
 struct iterator_transformer<
     transpose, 
     pack<
         base_iter_type_,
         type0_,
         type1_
     >,
     input_size_type_>
 {
 public:
     typedef transpose transform_type;
     typedef pack<
         base_iter_type_,
         type0_,
         type1_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
     typedef pack<
         base_iter_type_,
         type1_,
         type0_
         > iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i2);
         set<2>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i2);
         set<2>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i2);
         set<2>(res, org.i1);
     }
 };
 
 /***********************************************************************************************************/
 
 template<
     typename base_iter_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_>
 struct iterator_transformer<
     transpose, 
     pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_>
 {
 public:
     typedef transpose transform_type;
     typedef pack<
         base_iter_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef input_size_type_ input_size_type;
     typedef pack<
         base_iter_type_,
         type2_,
         type1_,
         type0_
         > iterator_type;
 
     static LITE_INLINE void transform(
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i3);
         set<2>(res, org.i2);
         set<3>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i3);
         set<2>(res, org.i2);
         set<3>(res, org.i1);
     }
 
     static LITE_INLINE void transform(
         const transform_type&, 
         const input_iterator_type& org, 
         const input_size_type&,
         iterator_type& res)
     {
         res.i0 = org.i0;
         set<1>(res, org.i3);
         set<2>(res, org.i2);
         set<3>(res, org.i1);
     }
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* block ***************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<int n0_ ..., int nN_>
 class block
 {
 public:
     typedef pack<...> size_type;
 
     block() {}
 
     block(const block& other);
 
     block(int n0, ..., int nN);
 
     block(const size_type& block_size, int i0 ..., int iN);
 
     block& operator=(const block& other);
 
     block operator()(int i0 ..., int iN) const;
 
     size_type block_size;
 
     int iX;
 };
 
 #else // DOCUMENTATION_ONLY
 
 
 template<
     >
 class block<
     >
 {
 public:
 
     typedef pack<
         > size_type;
 
     LITE_INLINE block() 
         : block_size()
     {}
 
     LITE_INLINE block(const block& other) 
         : block_size(other.block_size)
     {}
 
 
     LITE_INLINE block(const size_type& bs )
         : block_size(bs)
     {}
 
     LITE_INLINE block& operator=(const block& other) 
     {
         block_size = other.block_size;
         return *this;
     }
 
     LITE_INLINE block
     operator()() const
     {
         return block(block_size );
     }
 
     size_type block_size;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_
     >
 class block<
     n0_
     >
 {
 public:
 
     typedef pack<
         typename detail::type_if<n0_==1, int, constant<int, n0_> >::type
         > size_type;
 
     LITE_INLINE block() 
         : block_size(),
         i0()
     {}
 
     LITE_INLINE block(const block& other) 
         : block_size(other.block_size),
         i0(other.i0)
     {}
 
     LITE_INLINE block(int n0)
         : block_size(n0),
         i0()
     {}
 
     LITE_INLINE block(const size_type& bs, int i0)
         : block_size(bs),
         i0(i0)
     {}
 
     LITE_INLINE block& operator=(const block& other) 
     {
         block_size = other.block_size;
         i0 = other.i0;
         return *this;
     }
 
     LITE_INLINE block
     operator()(int i0) const
     {
         return block(block_size, i0);
     }
 
     size_type block_size;
     int i0;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_
     >
 class block<
     n0_,
     n1_
     >
 {
 public:
 
     typedef pack<
         typename detail::type_if<n0_==1, int, constant<int, n0_> >::type,
         typename detail::type_if<n1_==1, int, constant<int, n1_> >::type
         > size_type;
 
     LITE_INLINE block() 
         : block_size(),
         i0(), 
         i1()
     {}
 
     LITE_INLINE block(const block& other) 
         : block_size(other.block_size),
         i0(other.i0), 
         i1(other.i1)
     {}
 
     LITE_INLINE block(int n0, int n1)
         : block_size(n0, n1),
         i0(), 
         i1()
     {}
 
     LITE_INLINE block(const size_type& bs, int i0, int i1)
         : block_size(bs),
         i0(i0), 
         i1(i1)
     {}
 
     LITE_INLINE block& operator=(const block& other) 
     {
         block_size = other.block_size;
         i0 = other.i0;
         i1 = other.i1;
         return *this;
     }
 
     LITE_INLINE block
     operator()(int i0, int i1) const
     {
         return block(block_size, i0, i1);
     }
 
     size_type block_size;
     int i0;
     int i1;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_,
     int n2_
     >
 class block
 {
 public:
 
     typedef pack<
         typename detail::type_if<n0_==1, int, constant<int, n0_> >::type,
         typename detail::type_if<n1_==1, int, constant<int, n1_> >::type,
         typename detail::type_if<n2_==1, int, constant<int, n2_> >::type
         > size_type;
 
     LITE_INLINE block() 
         : block_size(),
         i0(), 
         i1(), 
         i2()
     {}
 
     LITE_INLINE block(const block& other) 
         : block_size(other.block_size),
         i0(other.i0), 
         i1(other.i1), 
         i2(other.i2)
     {}
 
     LITE_INLINE block(int n0, int n1, int n2)
         : block_size(n0, n1, n2),
         i0(), 
         i1(), 
         i2()
     {}
 
     LITE_INLINE block(const size_type& bs, int i0, int i1, int i2)
         : block_size(bs),
         i0(i0), 
         i1(i1), 
         i2(i2)
     {}
 
     LITE_INLINE block& operator=(const block& other) 
     {
         block_size = other.block_size;
         i0 = other.i0;
         i1 = other.i1;
         i2 = other.i2;
         return *this;
     }
 
     LITE_INLINE block
     operator()(int i0, int i1, int i2) const
     {
         return block(block_size, i0, i1, i2);
     }
 
     size_type block_size;
     int i0;
     int i1;
     int i2;
 };
 
 /***********************************************************************************************************/
  
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* size_transformer, block *********************************************************************************/
 /***********************************************************************************************************/
 
 
 template<
     >
 struct size_transformer<
     block<
     >, 
     pack<
     > >
 {
     typedef block<
         > transfrom_type;
 
     typedef pack<
         > input_size_type;
 
     typedef pack<
         > ex_size_type;
 
     typedef sub_pack<
         ex_size_type
         > sub_pack_type;
 
 
     typedef sub_pack_type::type size_type;
 
     static LITE_INLINE void transform(const transfrom_type&, const input_size_type&, size_type&)
     {}
 
 private:
     typedef detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     typename type0_
     >
 struct size_transformer<
     block<
         n0_
     >, 
     pack<
         type0_
     > >
 {
     typedef block<
         n0_
         > transfrom_type;
 
     typedef pack<
         type0_
         > input_size_type;
 
     typedef pack<
          typename detail::type_if<
             n0_ == -1, 
             type0_, 
             typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
             >::type
         > ex_size_type;
 
     typedef sub_pack<
         ex_size_type,
         n0_!=0
         > sub_pack_type;
 
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void 
     transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(
             res,
             n0_==-1 ? org.i0 : trans.block_size.i0
             ); 
         LITE_ARRAY_USE(trans);
         LITE_ARRAY_USE(org);
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_,
     typename type0_,
     typename type1_
     >
 struct size_transformer<
     block<
         n0_,
         n1_
     >, 
     pack<
         type0_,
         type1_
     > >
 {
     typedef block<
         n0_,
         n1_
         > transfrom_type;
 
     typedef pack<
         type0_,
         type1_
         > input_size_type;
 
     typedef pack<
          typename detail::type_if<
             n0_ == -1, 
             type0_, 
             typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
             >::type,
          typename detail::type_if<
             n1_ == -1, 
             type1_, 
             typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
             >::type
         > ex_size_type;
 
     typedef sub_pack<
         ex_size_type,
         n0_!=0,
         n1_!=0
         > sub_pack_type;
 
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void 
     transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(
             res,
             n0_==-1 ? org.i0 : trans.block_size.i0, 
             n1_==-1 ? org.i1 : trans.block_size.i1
             ); 
         LITE_ARRAY_USE(trans);
         LITE_ARRAY_USE(org);
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_,
     int n2_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct size_transformer<
     block<
         n0_,
         n1_,
         n2_
     >, 
     pack<
         type0_,
         type1_,
         type2_
     > >
 {
     typedef block<
         n0_,
         n1_,
         n2_
         > transfrom_type;
 
     typedef pack<
         type0_,
         type1_,
         type2_
         > input_size_type;
 
     typedef pack<
          typename detail::type_if<
             n0_ == -1, 
             type0_, 
             typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
             >::type,
          typename detail::type_if<
             n1_ == -1, 
             type1_, 
             typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
             >::type,
          typename detail::type_if<
             n2_ == -1, 
             type2_, 
             typename detail::type_if<n2_ == 1, int, constant<int, n2_> >::type
             >::type
         > ex_size_type;
 
     typedef sub_pack<
         ex_size_type,
         n0_!=0,
         n1_!=0,
         n2_!=0
         > sub_pack_type;
 
 
     typedef typename sub_pack_type::type size_type;
 
     static LITE_INLINE void 
     transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
     {
         sub_pack_type::set(
             res,
             n0_==-1 ? org.i0 : trans.block_size.i0, 
             n1_==-1 ? org.i1 : trans.block_size.i1, 
             n2_==-1 ? org.i2 : trans.block_size.i2
             ); 
         LITE_ARRAY_USE(trans);
         LITE_ARRAY_USE(org);
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 
 /***********************************************************************************************************/
 /* iterator_transformer, block *****************************************************************************/
 /***********************************************************************************************************/
 
 
 template<
     typename base_iterator_type_,
     typename input_size_type_
     >
 struct iterator_transformer<
     block<
     >,
     pack<
         base_iterator_type_
     >,
     input_size_type_
     >
 {
     typedef block<
         > transfrom_type;
 
     typedef pack<
         base_iterator_type_
         > input_iterator_type;
 
     typedef sub_pack<
         input_iterator_type,
         true
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             
         );
         
         LITE_ARRAY_USE(trans);
     }
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         const input_size_type_&, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             
         );
         
         LITE_ARRAY_USE(trans);
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     typename base_iterator_type_,
     typename type0_,
     typename input_size_type_
     >
 struct iterator_transformer<
     block<
         n0_
     >,
     pack<
         base_iterator_type_,
         type0_
     >,
     input_size_type_
     >
 {
     typedef block<
         n0_
         > transfrom_type;
 
     typedef pack<
         base_iterator_type_,
         type0_
         > input_iterator_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         n0_!=0
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             ,
             org.i1
         );
         
     }
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         const input_size_type_&, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             ,
             org.i1
         );
         
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_,
     typename base_iterator_type_,
     typename type0_,
     typename type1_,
     typename input_size_type_
     >
 struct iterator_transformer<
     block<
         n0_,
         n1_
     >,
     pack<
         base_iterator_type_,
         type0_,
         type1_
     >,
     input_size_type_
     >
 {
     typedef block<
         n0_,
         n1_
         > transfrom_type;
 
     typedef pack<
         base_iterator_type_,
         type0_,
         type1_
         > input_iterator_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         n0_!=0,
         n1_!=0
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             +(n1_ != -1 ? trans.i1*org.i2 : 0)
             ,
             org.i1,
             org.i2
         );
         
     }
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         const input_size_type_&, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             +(n1_ != -1 ? trans.i1*org.i2 : 0)
             ,
             org.i1,
             org.i2
         );
         
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 template<
     int n0_,
     int n1_,
     int n2_,
     typename base_iterator_type_,
     typename type0_,
     typename type1_,
     typename type2_,
     typename input_size_type_
     >
 struct iterator_transformer<
     block<
         n0_,
         n1_,
         n2_
     >,
     pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
     >,
     input_size_type_
     >
 {
     typedef block<
         n0_,
         n1_,
         n2_
         > transfrom_type;
 
     typedef pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
         > input_iterator_type;
 
     typedef sub_pack<
         input_iterator_type,
         true,
         n0_!=0,
         n1_!=0,
         n2_!=0
         > sub_pack_type;
 
     typedef typename sub_pack_type::type iterator_type;
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             +(n1_ != -1 ? trans.i1*org.i2 : 0)
             +(n2_ != -1 ? trans.i2*org.i3 : 0)
             ,
             org.i1,
             org.i2,
             org.i3
         );
         
     }
 
     static LITE_INLINE void
     transform(
         const transfrom_type& trans, 
         const input_iterator_type& org,
         const input_size_type_&, 
         iterator_type& res)
     {
         sub_pack_type::set(res, org.i0
             +(n0_ != -1 ? trans.i0*org.i1 : 0)
             +(n1_ != -1 ? trans.i1*org.i2 : 0)
             +(n2_ != -1 ? trans.i2*org.i3 : 0)
             ,
             org.i1,
             org.i2,
             org.i3
         );
         
     }
 
 private:
     typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
         ::verified verified;
 };
 
 /***********************************************************************************************************/
 
 /***********************************************************************************************************/
 /* array_signature_traits **********************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename signature_, typename base_iterator_type_>
 struct array_signature_traits
 {
     typedef ??? element_type;
 
     typedef ??? value_type;
 
     typedef signature_ signature;
 
     typedef ??? base_iterator_type;
 
     typedef ??? default_iterator;
 
     typedef ??? default_rev_iterator;
 
     typedef ??? size_type;
 
     static const int dimensions = ???;
 
     static const int volume = ???;
 
     static const bool is_fixed_size = ???;
 };
 
 #else // DOCUMENTATION_ONLY
 
 template<typename element_type_, typename base_iterator_type_>
 struct array_signature_traits
 {
     typedef element_type_ element_type;
     typedef typename detail::remove<element_type_, volatile const int>::type value_type;
     typedef value_type signature;
 
     typedef typename detail::type_if<
         detail::same_type<base_iterator_type_, void>::result,
         element_type_*,
         base_iterator_type_
         >::type base_iterator_type;
 
     typedef pack<base_iterator_type> default_iterator;
     typedef pack<base_iterator_type> default_rev_iterator;
     typedef pack<> size_type;
 
     static const int dimensions = 0;
     static const int volume = 1;
     static const bool is_fixed_size = true;
 };
 
 template<
     typename element_type_,
     int n0_, 
     typename base_iterator_type_>
 struct array_signature_traits<
     element_type_[n0_],
     base_iterator_type_>
 {
     typedef element_type_ element_type;
     typedef typename detail::remove<element_type_, volatile const int>::type value_type;
     typedef value_type signature[n0_];
 
     typedef typename detail::type_if<
         detail::same_type<base_iterator_type_, void>::result,
         element_type_*,
         base_iterator_type_
         >::type base_iterator_type;
 
     typedef pack<
         base_iterator_type,
         constant<int, 1>
         > default_iterator;
 
     typedef pack<
         base_iterator_type,
         constant<int, 1>
         > default_rev_iterator;
 
     typedef pack<
         typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
         > size_type;
 
     static const int dimensions = 1;
     static const int volume = n0_;
     static const bool is_fixed_size = n0_!=1;
 };
 
 template<
     typename element_type_,
     int n0_, 
     int n1_, 
     typename base_iterator_type_>
 struct array_signature_traits<
     element_type_[n0_][n1_],
     base_iterator_type_>
 {
     typedef element_type_ element_type;
     typedef typename detail::remove<element_type_, volatile const int>::type value_type;
     typedef value_type signature[n0_][n1_];
 
     typedef typename detail::type_if<
         detail::same_type<base_iterator_type_, void>::result,
         element_type_*,
         base_iterator_type_
         >::type base_iterator_type;
 
     typedef pack<
         base_iterator_type,
         typename detail::type_if<(n1_==1), int, constant<int, n1_> >::type,
         constant<int, 1>
         > default_iterator;
 
     typedef pack<
         base_iterator_type,
         constant<int, 1>,
         typename detail::type_if<(n0_==1), int, constant<int, n0_> >::type
         > default_rev_iterator;
 
     typedef pack<
         typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type,
         typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
         > size_type;
 
     static const int dimensions = 2;
     static const int volume = n0_ * n1_;
     static const bool is_fixed_size = n0_!=1 && n1_!=1;
 };
 
 template<
     typename element_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename base_iterator_type_>
 struct array_signature_traits<
     element_type_[n0_][n1_][n2_],
     base_iterator_type_>
 {
     typedef element_type_ element_type;
     typedef typename detail::remove<element_type_, volatile const int>::type value_type;
     typedef value_type signature[n0_][n1_][n2_];
 
     typedef typename detail::type_if<
         detail::same_type<base_iterator_type_, void>::result,
         element_type_*,
         base_iterator_type_
         >::type base_iterator_type;
 
     typedef pack<
         base_iterator_type,
         typename detail::type_if<(n1_==1||n2_==1), int, constant<int, n1_*n2_> >::type,
         typename detail::type_if<(n2_==1), int, constant<int, n2_> >::type,
         constant<int, 1>
         > default_iterator;
 
     typedef pack<
         base_iterator_type,
         constant<int, 1>,
         typename detail::type_if<(n0_==1), int, constant<int, n0_> >::type,
         typename detail::type_if<(n1_==1||n0_==1), int, constant<int, n1_*n0_> >::type
         > default_rev_iterator;
 
     typedef pack<
         typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type,
         typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type,
         typename detail::type_if<n2_ == 1, int, constant<int, n2_> >::type
         > size_type;
 
     static const int dimensions = 3;
     static const int volume = n0_ * n1_ * n2_;
     static const bool is_fixed_size = n0_!=1 && n1_!=1 && n2_!=1;
 };
 
 
 
 template<
     typename element_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     int n3_, 
     typename base_iterator_type_>
 struct array_signature_traits<
     element_type_[n0_][n1_][n2_][n3_],
     base_iterator_type_>
 {
     typedef element_type_ element_type;
     typedef typename detail::remove<element_type_, volatile const int>::type value_type;
     typedef value_type signature[n0_][n1_][n2_][n3_];
 
     // too many dimensions!
     //typedef ??? default_iterator;
     //typedef ??? default_rev_iterator;
     //typedef ??? size_type;
 
     static const int dimensions = 3+1;
     static const int volume = n0_ * n1_ * n2_ * n3_;
     static const bool is_fixed_size = n0_!=1 && n1_!=1 && n2_!=1 && n3_!=1;
 };
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* array_helper ********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_>
 struct array_helper
 {
     typedef array<signature_, traits_type_, 
         typename traits_type_::template representation_type<signature_>::temporary_type> 
         temporary_array;
 
     typedef array<signature_, traits_type_, 
         typename traits_type_::template representation_type<signature_>::fwd_temporary_type> 
         fwd_temporary_array;
 
     typedef array<signature_, traits_type_, 
         typename traits_type_::template representation_type<signature_>::rev_temporary_type> 
         rev_temporary_array;
 };
 
 /***********************************************************************************************************/
 /* for_each, helpers ***************************************************************************************/
 /***********************************************************************************************************/
 
 namespace detail
 {
 
 template<typename iterator_type_, int dim_=0>
 struct g_iterator_traits;
 
 /***********************************************************************************************************/
 /* g_iterator_traits, s_iterator ***************************************************************************/
 /***********************************************************************************************************/
 
 template<typename base_iterator_type_>
 struct g_iterator_traits<pack<base_iterator_type_>, 0>
 {
     typedef pack<base_iterator_type_> iterator_type;
 
     static const int complexity = 1;
     static const int non_unit_strides_count = 0;
     static const int constant_strides_count = 0;
     static const int variable_strides_count = 0;
 };
 
 template<
     typename base_iterator_type_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct g_iterator_traits<
     pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
     >,
     0
     >   
 {
     typedef pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
         > iterator_type;
 
     static const int complexity = 2;
     static const int non_unit_strides_count = 
         detail::same_type<type0_, constant<int, 1> >::result ? 0 : 1;
     static const int constant_strides_count = iterator_type::is_const1 ? 1 : 0;
     static const int variable_strides_count = iterator_type::is_const1 ? 0 : 1;
 };
 template<
     typename base_iterator_type_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct g_iterator_traits<
     pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
     >,
     1
     >   
 {
     typedef pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
         > iterator_type;
 
     static const int complexity = 2;
     static const int non_unit_strides_count = 
         detail::same_type<type1_, constant<int, 1> >::result ? 0 : 1;
     static const int constant_strides_count = iterator_type::is_const2 ? 1 : 0;
     static const int variable_strides_count = iterator_type::is_const2 ? 0 : 1;
 };
 template<
     typename base_iterator_type_,
     typename type0_,
     typename type1_,
     typename type2_
     >
 struct g_iterator_traits<
     pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
     >,
     2
     >   
 {
     typedef pack<
         base_iterator_type_,
         type0_,
         type1_,
         type2_
         > iterator_type;
 
     static const int complexity = 2;
     static const int non_unit_strides_count = 
         detail::same_type<type2_, constant<int, 1> >::result ? 0 : 1;
     static const int constant_strides_count = iterator_type::is_const3 ? 1 : 0;
     static const int variable_strides_count = iterator_type::is_const3 ? 0 : 1;
 };
 
 /***********************************************************************************************************/
 /* g_iterator_traits, c_iterator ***************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, int dim_>
 struct g_iterator_traits<c_iterator<value_type_>, dim_>
 {
     typedef c_iterator<value_type_> iterator_type;
 
     static const int complexity = 1;
     static const int non_unit_strides_count = 0;
     static const int constant_strides_count = 0;
     static const int variable_strides_count = 0;
 };
 
 /***********************************************************************************************************/
 /* g_iterator_traits, u_iterator ***************************************************************************/
 /***********************************************************************************************************/
 
 template<typename base_iter_type_, typename func_type_, bool is_static_, int dim_>
 struct g_iterator_traits<u_iterator<base_iter_type_, func_type_, is_static_>, dim_>
 {
     typedef u_iterator<base_iter_type_, func_type_, is_static_> iterator_type;
 
     static const int complexity = 
         g_iterator_traits<base_iter_type_, dim_>::complexity+1;
 
     static const int non_unit_strides_count =
         g_iterator_traits<base_iter_type_, dim_>::non_unit_strides_count;
 
     static const int constant_strides_count = 
         g_iterator_traits<base_iter_type_, dim_>::constant_strides_count;
 
     static const int variable_strides_count = 
         g_iterator_traits<base_iter_type_, dim_>::variable_strides_count;
 };
 
 /***********************************************************************************************************/
 /* g_iterator_traits, b_iterator ***************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename left_base_iter_type_, 
     typename right_base_iter_type_, 
     typename func_type_, 
     bool is_static_, 
     int dim_>
 struct g_iterator_traits<
     b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>, dim_>
 {
     typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_> iterator_type;
 
     static const int complexity = 
         g_iterator_traits<left_base_iter_type_, dim_>::complexity
         +g_iterator_traits<right_base_iter_type_, dim_>::complexity+1;
 
     static const int non_unit_strides_count =
         g_iterator_traits<left_base_iter_type_, dim_>::non_unit_strides_count
         +g_iterator_traits<right_base_iter_type_, dim_>::non_unit_strides_count;
 
     static const int constant_strides_count = 
         g_iterator_traits<left_base_iter_type_, dim_>::constant_strides_count
         +g_iterator_traits<right_base_iter_type_, dim_>::constant_strides_count;
 
     static const int variable_strides_count = 
         g_iterator_traits<left_base_iter_type_, dim_>::variable_strides_count
         +g_iterator_traits<right_base_iter_type_, dim_>::variable_strides_count;
 };
 
 /***********************************************************************************************************/
 /* g_iterator_policy ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_, int dim_=0>
 struct g_iterator_policy
 {
     typedef g_iterator_traits<iterator_type_, dim_> traits_type;
 
     static const bool use_index = traits_type::constant_strides_count >= traits_type::variable_strides_count;
     //?? add other policy
 };
 
 /***********************************************************************************************************/
 /* matrix_policy *******************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename array_type_, int freq_>
 struct matrix_policy
 {};
 
 /***********************************************************************************************************/
 
 template<typename value_type_, int n0_, typename traits_type_, typename _rep, int freq_>
 struct matrix_policy<array<value_type_[n0_], traits_type_, _rep>, freq_>
 {
     typedef array<value_type_[n0_], traits_type_, _rep> original_array_type;
 
     typedef g_iterator_traits<typename original_array_type::iterator, 0> g_iterator_traits0;
 
     static const bool should_cache_dim0 = 
         freq_ <= 1 ? g_iterator_traits0::complexity > 8 :
         freq_ <= 2 ? g_iterator_traits0::complexity > 2 || g_iterator_traits0::variable_strides_count > 2 :
         g_iterator_traits0::complexity > 2 
         || g_iterator_traits0::variable_strides_count > 0 
         || g_iterator_traits0::non_unit_strides_count > 0;
 
     typedef typename type_if<
         should_cache_dim0, 
         typename array_helper<value_type_[n0_], traits_type_>::temporary_array,
         const original_array_type&
         >::type cached_array;
 };
 
 /***********************************************************************************************************/
 
 template<typename value_type_, int n0_, int n1_, typename traits_type_, typename _rep, int freq_>
 struct matrix_policy<array<value_type_[n0_][n1_], traits_type_, _rep>,  freq_>
 {
     typedef array<value_type_[n0_][n1_], traits_type_, _rep> original_array_type;
 
     typedef g_iterator_traits<typename original_array_type::iterator, 0> g_iterator_traits0;
     typedef g_iterator_traits<typename original_array_type::iterator, 1> g_iterator_traits1;
 
     static const bool should_cache_dim0 = 
         freq_ <= 1 ? g_iterator_traits0::complexity > 8 :
         freq_ <= 2 ? g_iterator_traits0::complexity > 2 || g_iterator_traits0::variable_strides_count > 2 :
         g_iterator_traits0::complexity > 2 
         || g_iterator_traits0::variable_strides_count > 0
         || g_iterator_traits0::non_unit_strides_count > 0;
 
 
     static const bool should_cache_dim1 = 
         freq_ <= 1 ? g_iterator_traits1::complexity > 8 :
         freq_ <= 2 ? g_iterator_traits1::complexity > 2 || g_iterator_traits1::variable_strides_count > 2 :
         g_iterator_traits1::complexity > 2 
         || g_iterator_traits1::variable_strides_count > 0
         || g_iterator_traits0::non_unit_strides_count > 0;
 
     typedef typename type_if<
         should_cache_dim0, 
         typename array_helper<value_type_[n0_][n1_], traits_type_>::fwd_temporary_array,
         const original_array_type&
         >::type cached_fwd_array;
 
     typedef typename type_if<
         should_cache_dim1, 
         typename array_helper<value_type_[n0_][n1_], traits_type_>::rev_temporary_array,
         const original_array_type&
         >::type cached_rev_array;
 };
 
 /***********************************************************************************************************/
 
 template<typename value_type_, int n0_, int n1_, int n2_, typename traits_type_, typename _rep, int freq_>
 struct matrix_policy<array<value_type_[n0_][n1_][n2_], traits_type_, _rep>, freq_>
 {};
 
 } // namespace detail
 
 /***********************************************************************************************************/
 /* for_each ************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename iterator_type_, typename size_type_>
 LITE_INLINE void for_each(const iterator_type_& iter, const size_type_& size);
 
 template<typename iterator_type_, typename function_type_, typename size_type_>
 LITE_INLINE void for_each(const iterator_type_& iter, function_type_& func, const size_type_& size);
 
 template<typename iterator_type_, typename size_type_>
 LITE_INLINE bool for_each_c(const iterator_type_& iter, const size_type_& size);
 
 template<typename iterator_type_, typename function_type_, typename size_type_>
 LITE_INLINE bool for_each_c(const iterator_type_& iter, function_type_& func, const size_type_& size);
 
 #else // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* for_each, 0D arrays *************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_>
 LITE_INLINE void
 for_each(const iterator_type_& iter, const pack<>&)
 {
     at(iter);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE void
 for_each(const iterator_type_& iter, function_type_& func, const pack<>&)
 {
     func(at(iter));
 }
 
 template<typename iterator_type_>
 LITE_INLINE bool
 for_each_c(const iterator_type_& iter, const pack<>&)
 {
     return at(iter);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE bool
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<>&)
 {
     return func(at(iter));
 }
 
 /***********************************************************************************************************/
 /* for_each, 1D small arrays, use_index ********************************************************************/
 /***********************************************************************************************************/
 
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 1> >&)
 {
     at(iter, 0);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 1> >&)
 {
     func(at(iter, 0));
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 1> >&)
 {
     if (!func(at(iter, 0))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 1> >&)
 {
     if (!at(iter, 0)) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 2> >&)
 {
     at(iter, 0);
     at(iter, 1);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 2> >&)
 {
     func(at(iter, 0));
     func(at(iter, 1));
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 2> >&)
 {
     if (!func(at(iter, 0))) return false;
     if (!func(at(iter, 1))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 2> >&)
 {
     if (!at(iter, 0)) return false;
     if (!at(iter, 1)) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 3> >&)
 {
     at(iter, 0);
     at(iter, 1);
     at(iter, 2);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 3> >&)
 {
     func(at(iter, 0));
     func(at(iter, 1));
     func(at(iter, 2));
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 3> >&)
 {
     if (!func(at(iter, 0))) return false;
     if (!func(at(iter, 1))) return false;
     if (!func(at(iter, 2))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 3> >&)
 {
     if (!at(iter, 0)) return false;
     if (!at(iter, 1)) return false;
     if (!at(iter, 2)) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 4> >&)
 {
     at(iter, 0);
     at(iter, 1);
     at(iter, 2);
     at(iter, 3);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 4> >&)
 {
     func(at(iter, 0));
     func(at(iter, 1));
     func(at(iter, 2));
     func(at(iter, 3));
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 4> >&)
 {
     if (!func(at(iter, 0))) return false;
     if (!func(at(iter, 1))) return false;
     if (!func(at(iter, 2))) return false;
     if (!func(at(iter, 3))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 4> >&)
 {
     if (!at(iter, 0)) return false;
     if (!at(iter, 1)) return false;
     if (!at(iter, 2)) return false;
     if (!at(iter, 3)) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 5> >&)
 {
     at(iter, 0);
     at(iter, 1);
     at(iter, 2);
     at(iter, 3);
     at(iter, 4);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 5> >&)
 {
     func(at(iter, 0));
     func(at(iter, 1));
     func(at(iter, 2));
     func(at(iter, 3));
     func(at(iter, 4));
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 5> >&)
 {
     if (!func(at(iter, 0))) return false;
     if (!func(at(iter, 1))) return false;
     if (!func(at(iter, 2))) return false;
     if (!func(at(iter, 3))) return false;
     if (!func(at(iter, 4))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 5> >&)
 {
     if (!at(iter, 0)) return false;
     if (!at(iter, 1)) return false;
     if (!at(iter, 2)) return false;
     if (!at(iter, 3)) return false;
     if (!at(iter, 4)) return false;
     return true;
 }
 
 /***********************************************************************************************************/
 /* for_each, 1D small arrays, !use_index =*******************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 6> >&)
 {
     iterator_type_ it = iter;
 
     at(it, 0); inc<0>(it); 
     at(it, 1); inc<0>(it); 
     at(it, 2); inc<0>(it); 
     at(it, 3); inc<0>(it); 
     at(it, 4); inc<0>(it); 
     at(it, 5);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 6> >&)
 {
     iterator_type_ it = iter;
 
     func(at(it, 0)); inc<0>(it); 
     func(at(it, 1)); inc<0>(it); 
     func(at(it, 2)); inc<0>(it); 
     func(at(it, 3)); inc<0>(it); 
     func(at(it, 4)); inc<0>(it); 
     func(at(it, 5));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<constant<int, 6> >&)
 {
     iterator_type_ it = iter;
 
     if (!at(iter, 0)) return false; inc<0>(it); 
     if (!at(iter, 1)) return false; inc<0>(it); 
     if (!at(iter, 2)) return false; inc<0>(it); 
     if (!at(iter, 3)) return false; inc<0>(it); 
     if (!at(iter, 4)) return false; inc<0>(it); 
     if (!at(iter, 5)) return false;
 
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 6> >&)
 {
     iterator_type_ it = iter;
 
     if (!func(at(iter, 0))) return false; inc<0>(it); 
     if (!func(at(iter, 1))) return false; inc<0>(it); 
     if (!func(at(iter, 2))) return false; inc<0>(it); 
     if (!func(at(iter, 3))) return false; inc<0>(it); 
     if (!func(at(iter, 4))) return false; inc<0>(it); 
     if (!func(at(iter, 5))) return false;
 
     return true;
 }
 
 /***********************************************************************************************************/
 /* for_each, 1D arrays, use_index **************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         at(it, 0); 
         at(it, 1); 
         at(it, 2); 
         at(it, 3); 
         at(it, 4); 
         at(it, 5); 
         at(it, 6); 
         at(it, 7); 
         at(it, 8); 
         at(it, 9); 
         at(it, 10); 
         at(it, 11); 
         at(it, 12); 
         at(it, 13); 
         at(it, 14); 
         at(it, 15); 
         shift<0>(it, 16);
     }
 
     if (n & 8) {
         at(it, 0);
         at(it, 1);
         at(it, 2);
         at(it, 3);
         at(it, 4);
         at(it, 5);
         at(it, 6);
         at(it, 7);
         shift<0>(it, 8);
     }
     if (n & 4) {
         at(it, 0);
         at(it, 1);
         at(it, 2);
         at(it, 3);
         shift<0>(it, 4);
     }
     if (n & 2) {
         at(it, 0);
         at(it, 1);
         shift<0>(it, 2);
     }
 
     if (n & 1)
         at(it, 0);
 
     LITE_ARRAY_USE(size);
 }
 
 template<typename iterator_type_, typename function_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         func(at(it, 0)); 
         func(at(it, 1)); 
         func(at(it, 2)); 
         func(at(it, 3)); 
         func(at(it, 4)); 
         func(at(it, 5)); 
         func(at(it, 6)); 
         func(at(it, 7)); 
         func(at(it, 8)); 
         func(at(it, 9)); 
         func(at(it, 10)); 
         func(at(it, 11)); 
         func(at(it, 12)); 
         func(at(it, 13)); 
         func(at(it, 14)); 
         func(at(it, 15)); 
         shift<0>(it, 16);
     }
 
     if (n & 8) {
         func(at(it, 0));
         func(at(it, 1));
         func(at(it, 2));
         func(at(it, 3));
         func(at(it, 4));
         func(at(it, 5));
         func(at(it, 6));
         func(at(it, 7));
         shift<0>(it, 8);
     }
     if (n & 4) {
         func(at(it, 0));
         func(at(it, 1));
         func(at(it, 2));
         func(at(it, 3));
         shift<0>(it, 4);
     }
     if (n & 2) {
         func(at(it, 0));
         func(at(it, 1));
         shift<0>(it, 2);
     }
 
     if (n & 1)
         func(at(it, 0));
 
     LITE_ARRAY_USE(size);
 }
 
 template<typename iterator_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         if (!at(it, 0)) return false; 
         if (!at(it, 1)) return false; 
         if (!at(it, 2)) return false; 
         if (!at(it, 3)) return false; 
         if (!at(it, 4)) return false; 
         if (!at(it, 5)) return false; 
         if (!at(it, 6)) return false; 
         if (!at(it, 7)) return false; 
         if (!at(it, 8)) return false; 
         if (!at(it, 9)) return false; 
         if (!at(it, 10)) return false; 
         if (!at(it, 11)) return false; 
         if (!at(it, 12)) return false; 
         if (!at(it, 13)) return false; 
         if (!at(it, 14)) return false; 
         if (!at(it, 15)) return false; 
         shift<0>(it, 16);
     }
 
     if (n & 8) {
         if (!at(it, 0)) return false; 
         if (!at(it, 1)) return false; 
         if (!at(it, 2)) return false; 
         if (!at(it, 3)) return false; 
         if (!at(it, 4)) return false; 
         if (!at(it, 5)) return false; 
         if (!at(it, 6)) return false; 
         if (!at(it, 7)) return false; 
         shift<0>(it, 8);
     }
     if (n & 4) {
         if (!at(it, 0)) return false; 
         if (!at(it, 1)) return false; 
         if (!at(it, 2)) return false; 
         if (!at(it, 3)) return false; 
         shift<0>(it, 4);
     }
     if (n & 2) {
         if (!at(it, 0)) return false; 
         if (!at(it, 1)) return false; 
         shift<0>(it, 2);
     }
 
     if (n & 1)
         if (!at(it, 0)) return false; 
 
     return true;
     LITE_ARRAY_USE(size);
 }
 
 template<typename iterator_type_, typename function_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         if (!func(at(it, 0))) return false; 
         if (!func(at(it, 1))) return false; 
         if (!func(at(it, 2))) return false; 
         if (!func(at(it, 3))) return false; 
         if (!func(at(it, 4))) return false; 
         if (!func(at(it, 5))) return false; 
         if (!func(at(it, 6))) return false; 
         if (!func(at(it, 7))) return false; 
         if (!func(at(it, 8))) return false; 
         if (!func(at(it, 9))) return false; 
         if (!func(at(it, 10))) return false; 
         if (!func(at(it, 11))) return false; 
         if (!func(at(it, 12))) return false; 
         if (!func(at(it, 13))) return false; 
         if (!func(at(it, 14))) return false; 
         if (!func(at(it, 15))) return false; 
         shift<0>(it, 16);
     }
 
     if (n & 8) {
         if (!func(at(it, 0))) return false; 
         if (!func(at(it, 1))) return false; 
         if (!func(at(it, 2))) return false; 
         if (!func(at(it, 3))) return false; 
         if (!func(at(it, 4))) return false; 
         if (!func(at(it, 5))) return false; 
         if (!func(at(it, 6))) return false; 
         if (!func(at(it, 7))) return false; 
         shift<0>(it, 8);
     }
     if (n & 4) {
         if (!func(at(it, 0))) return false; 
         if (!func(at(it, 1))) return false; 
         if (!func(at(it, 2))) return false; 
         if (!func(at(it, 3))) return false; 
         shift<0>(it, 4);
     }
     if (n & 2) {
         if (!func(at(it, 0))) return false; 
         if (!func(at(it, 1))) return false; 
         shift<0>(it, 2);
     }
 
     if (n & 1)
         if (!func(at(it, 0))) return false; 
 
     return true;
     LITE_ARRAY_USE(size);
 }
 
 /***********************************************************************************************************/
 /* for_each, 1D arrays, !use_index *************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
     }
 
     if (n & 8) {
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
     }
     if (n & 4) {
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
         at(it); inc<0>(it);
     }
     if (n & 2) {
         at(it); inc<0>(it);
         at(it); inc<0>(it);
     }
 
     if (n & 1)
         at(it);
     LITE_ARRAY_USE(size);
 }
 
 template<typename iterator_type_, typename function_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
     }
 
     if (n & 8) {
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
     }
     if (n & 4) {
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
     }
     if (n & 2) {
         func(at(it)); inc<0>(it);
         func(at(it)); inc<0>(it);
     }
 
     if (n & 1)
         func(at(it));
     LITE_ARRAY_USE(size);
 }
 
 template<typename iterator_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
     }
 
     if (n & 8) {
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
     }
     if (n & 4) {
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
     }
     if (n & 2) {
         if(!at(it)) return false; inc<0>(it);
         if(!at(it)) return false; inc<0>(it);
     }
 
     if (n & 1)
         if(!at(it)) return false;
 
     return true;
     LITE_ARRAY_USE(size);
 }
 
 
 template<typename iterator_type_, typename function_type_, typename type_>
 LITE_INLINE 
 typename detail::enable_if<(
     !detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
 {
     const int n = size.i0;
     int j=16;
     iterator_type_ it = iter;
 
     for (; j<=n; j+=16) {
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
     }
 
     if (n & 8) {
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
     }
     if (n & 4) {
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
     }
     if (n & 2) {
         if(!func(at(it))) return false; inc<0>(it);
         if(!func(at(it))) return false; inc<0>(it);
     }
 
     if (n & 1)
         if(!func(at(it))) return false; inc<0>(it);
 
     return true;
     LITE_ARRAY_USE(size);
 }
 
 /***********************************************************************************************************/
 /* for_each, small square 2D arrays, use_index *************************************************************/
 /***********************************************************************************************************/
 
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 1>, constant<int, 1> >&)
 {
     at(iter, 0, 0);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 1>, constant<int, 1> >&)
 {
     func(at(iter, 0, 0));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     const pack<constant<int, 1>, constant<int, 1> >&)
 {
     if (!at(iter, 0, 0)) return false;
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 1>, constant<int, 1> >&)
 {
     if (!func(at(iter, 0, 0))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 2>, constant<int, 2> >&)
 {
     at(iter, 0, 0);
     at(iter, 0, 1);
     at(iter, 1, 0);
     at(iter, 1, 1);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 2>, constant<int, 2> >&)
 {
     func(at(iter, 0, 0));
     func(at(iter, 0, 1));
     func(at(iter, 1, 0));
     func(at(iter, 1, 1));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     const pack<constant<int, 2>, constant<int, 2> >&)
 {
     if (!at(iter, 0, 0)) return false;
     if (!at(iter, 0, 1)) return false;
     if (!at(iter, 1, 0)) return false;
     if (!at(iter, 1, 1)) return false;
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 2>, constant<int, 2> >&)
 {
     if (!func(at(iter, 0, 0))) return false;
     if (!func(at(iter, 0, 1))) return false;
     if (!func(at(iter, 1, 0))) return false;
     if (!func(at(iter, 1, 1))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 3>, constant<int, 3> >&)
 {
     at(iter, 0, 0);
     at(iter, 0, 1);
     at(iter, 0, 2);
     at(iter, 1, 0);
     at(iter, 1, 1);
     at(iter, 1, 2);
     at(iter, 2, 0);
     at(iter, 2, 1);
     at(iter, 2, 2);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 3>, constant<int, 3> >&)
 {
     func(at(iter, 0, 0));
     func(at(iter, 0, 1));
     func(at(iter, 0, 2));
     func(at(iter, 1, 0));
     func(at(iter, 1, 1));
     func(at(iter, 1, 2));
     func(at(iter, 2, 0));
     func(at(iter, 2, 1));
     func(at(iter, 2, 2));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     const pack<constant<int, 3>, constant<int, 3> >&)
 {
     if (!at(iter, 0, 0)) return false;
     if (!at(iter, 0, 1)) return false;
     if (!at(iter, 0, 2)) return false;
     if (!at(iter, 1, 0)) return false;
     if (!at(iter, 1, 1)) return false;
     if (!at(iter, 1, 2)) return false;
     if (!at(iter, 2, 0)) return false;
     if (!at(iter, 2, 1)) return false;
     if (!at(iter, 2, 2)) return false;
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 3>, constant<int, 3> >&)
 {
     if (!func(at(iter, 0, 0))) return false;
     if (!func(at(iter, 0, 1))) return false;
     if (!func(at(iter, 0, 2))) return false;
     if (!func(at(iter, 1, 0))) return false;
     if (!func(at(iter, 1, 1))) return false;
     if (!func(at(iter, 1, 2))) return false;
     if (!func(at(iter, 2, 0))) return false;
     if (!func(at(iter, 2, 1))) return false;
     if (!func(at(iter, 2, 2))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 4>, constant<int, 4> >&)
 {
     at(iter, 0, 0);
     at(iter, 0, 1);
     at(iter, 0, 2);
     at(iter, 0, 3);
     at(iter, 1, 0);
     at(iter, 1, 1);
     at(iter, 1, 2);
     at(iter, 1, 3);
     at(iter, 2, 0);
     at(iter, 2, 1);
     at(iter, 2, 2);
     at(iter, 2, 3);
     at(iter, 3, 0);
     at(iter, 3, 1);
     at(iter, 3, 2);
     at(iter, 3, 3);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 4>, constant<int, 4> >&)
 {
     func(at(iter, 0, 0));
     func(at(iter, 0, 1));
     func(at(iter, 0, 2));
     func(at(iter, 0, 3));
     func(at(iter, 1, 0));
     func(at(iter, 1, 1));
     func(at(iter, 1, 2));
     func(at(iter, 1, 3));
     func(at(iter, 2, 0));
     func(at(iter, 2, 1));
     func(at(iter, 2, 2));
     func(at(iter, 2, 3));
     func(at(iter, 3, 0));
     func(at(iter, 3, 1));
     func(at(iter, 3, 2));
     func(at(iter, 3, 3));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     const pack<constant<int, 4>, constant<int, 4> >&)
 {
     if (!at(iter, 0, 0)) return false;
     if (!at(iter, 0, 1)) return false;
     if (!at(iter, 0, 2)) return false;
     if (!at(iter, 0, 3)) return false;
     if (!at(iter, 1, 0)) return false;
     if (!at(iter, 1, 1)) return false;
     if (!at(iter, 1, 2)) return false;
     if (!at(iter, 1, 3)) return false;
     if (!at(iter, 2, 0)) return false;
     if (!at(iter, 2, 1)) return false;
     if (!at(iter, 2, 2)) return false;
     if (!at(iter, 2, 3)) return false;
     if (!at(iter, 3, 0)) return false;
     if (!at(iter, 3, 1)) return false;
     if (!at(iter, 3, 2)) return false;
     if (!at(iter, 3, 3)) return false;
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 4>, constant<int, 4> >&)
 {
     if (!func(at(iter, 0, 0))) return false;
     if (!func(at(iter, 0, 1))) return false;
     if (!func(at(iter, 0, 2))) return false;
     if (!func(at(iter, 0, 3))) return false;
     if (!func(at(iter, 1, 0))) return false;
     if (!func(at(iter, 1, 1))) return false;
     if (!func(at(iter, 1, 2))) return false;
     if (!func(at(iter, 1, 3))) return false;
     if (!func(at(iter, 2, 0))) return false;
     if (!func(at(iter, 2, 1))) return false;
     if (!func(at(iter, 2, 2))) return false;
     if (!func(at(iter, 2, 3))) return false;
     if (!func(at(iter, 3, 0))) return false;
     if (!func(at(iter, 3, 1))) return false;
     if (!func(at(iter, 3, 2))) return false;
     if (!func(at(iter, 3, 3))) return false;
     return true;
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(const iterator_type_& iter, const pack<constant<int, 5>, constant<int, 5> >&)
 {
     at(iter, 0, 0);
     at(iter, 0, 1);
     at(iter, 0, 2);
     at(iter, 0, 3);
     at(iter, 0, 4);
     at(iter, 1, 0);
     at(iter, 1, 1);
     at(iter, 1, 2);
     at(iter, 1, 3);
     at(iter, 1, 4);
     at(iter, 2, 0);
     at(iter, 2, 1);
     at(iter, 2, 2);
     at(iter, 2, 3);
     at(iter, 2, 4);
     at(iter, 3, 0);
     at(iter, 3, 1);
     at(iter, 3, 2);
     at(iter, 3, 3);
     at(iter, 3, 4);
     at(iter, 4, 0);
     at(iter, 4, 1);
     at(iter, 4, 2);
     at(iter, 4, 3);
     at(iter, 4, 4);
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     )>::type 
 for_each(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 5>, constant<int, 5> >&)
 {
     func(at(iter, 0, 0));
     func(at(iter, 0, 1));
     func(at(iter, 0, 2));
     func(at(iter, 0, 3));
     func(at(iter, 0, 4));
     func(at(iter, 1, 0));
     func(at(iter, 1, 1));
     func(at(iter, 1, 2));
     func(at(iter, 1, 3));
     func(at(iter, 1, 4));
     func(at(iter, 2, 0));
     func(at(iter, 2, 1));
     func(at(iter, 2, 2));
     func(at(iter, 2, 3));
     func(at(iter, 2, 4));
     func(at(iter, 3, 0));
     func(at(iter, 3, 1));
     func(at(iter, 3, 2));
     func(at(iter, 3, 3));
     func(at(iter, 3, 4));
     func(at(iter, 4, 0));
     func(at(iter, 4, 1));
     func(at(iter, 4, 2));
     func(at(iter, 4, 3));
     func(at(iter, 4, 4));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     const pack<constant<int, 5>, constant<int, 5> >&)
 {
     if (!at(iter, 0, 0)) return false;
     if (!at(iter, 0, 1)) return false;
     if (!at(iter, 0, 2)) return false;
     if (!at(iter, 0, 3)) return false;
     if (!at(iter, 0, 4)) return false;
     if (!at(iter, 1, 0)) return false;
     if (!at(iter, 1, 1)) return false;
     if (!at(iter, 1, 2)) return false;
     if (!at(iter, 1, 3)) return false;
     if (!at(iter, 1, 4)) return false;
     if (!at(iter, 2, 0)) return false;
     if (!at(iter, 2, 1)) return false;
     if (!at(iter, 2, 2)) return false;
     if (!at(iter, 2, 3)) return false;
     if (!at(iter, 2, 4)) return false;
     if (!at(iter, 3, 0)) return false;
     if (!at(iter, 3, 1)) return false;
     if (!at(iter, 3, 2)) return false;
     if (!at(iter, 3, 3)) return false;
     if (!at(iter, 3, 4)) return false;
     if (!at(iter, 4, 0)) return false;
     if (!at(iter, 4, 1)) return false;
     if (!at(iter, 4, 2)) return false;
     if (!at(iter, 4, 3)) return false;
     if (!at(iter, 4, 4)) return false;
     return true;
 }
 
 template<typename iterator_type_, typename function_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     detail::g_iterator_policy<iterator_type_>::use_index
     ), bool>::type 
 for_each_c(
     const iterator_type_& iter, 
     function_type_& func, 
     const pack<constant<int, 5>, constant<int, 5> >&)
 {
     if (!func(at(iter, 0, 0))) return false;
     if (!func(at(iter, 0, 1))) return false;
     if (!func(at(iter, 0, 2))) return false;
     if (!func(at(iter, 0, 3))) return false;
     if (!func(at(iter, 0, 4))) return false;
     if (!func(at(iter, 1, 0))) return false;
     if (!func(at(iter, 1, 1))) return false;
     if (!func(at(iter, 1, 2))) return false;
     if (!func(at(iter, 1, 3))) return false;
     if (!func(at(iter, 1, 4))) return false;
     if (!func(at(iter, 2, 0))) return false;
     if (!func(at(iter, 2, 1))) return false;
     if (!func(at(iter, 2, 2))) return false;
     if (!func(at(iter, 2, 3))) return false;
     if (!func(at(iter, 2, 4))) return false;
     if (!func(at(iter, 3, 0))) return false;
     if (!func(at(iter, 3, 1))) return false;
     if (!func(at(iter, 3, 2))) return false;
     if (!func(at(iter, 3, 3))) return false;
     if (!func(at(iter, 3, 4))) return false;
     if (!func(at(iter, 4, 0))) return false;
     if (!func(at(iter, 4, 1))) return false;
     if (!func(at(iter, 4, 2))) return false;
     if (!func(at(iter, 4, 3))) return false;
     if (!func(at(iter, 4, 4))) return false;
     return true;
 }
 
 /***********************************************************************************************************/
 /* for_each, nD arrays *************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_, typename size_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     size_type_::n > 1
     )>::type 
 for_each(const iterator_type_& iter, const size_type_& size)
 {
     typedef size_transformer<plane<0>, size_type_> s_transformer;
     typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;
 
     iterator_type_ it = iter;
     typename s_transformer::size_type new_size;
     typename i_transformer::iterator_type new_it;
     const int n = size.i0;
 
     s_transformer::transform(size, new_size);
 
     for (int i=0; i<n; i++) {
         i_transformer::transform(it, new_it);
         for_each(new_it, new_size);
         inc<0>(it);
     }
 }
 
 template<typename iterator_type_, typename function_type_, typename size_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     size_type_::n > 1
     )>::type 
 for_each(const iterator_type_& iter, function_type_& func, const size_type_& size)
 {
     typedef size_transformer<plane<0>, size_type_> s_transformer;
     typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;
 
     iterator_type_ it = iter;
     typename s_transformer::size_type new_size;
     typename i_transformer::iterator_type new_it;
     const int n = size.i0;
 
     s_transformer::transform(size, new_size);
 
     for (int i=0; i<n; i++) {
         i_transformer::transform(it, new_it);
         for_each(new_it, func, new_size);
         inc<0>(it);
     }
 }
 
 template<typename iterator_type_, typename size_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     size_type_::n > 1
     ), bool>::type 
 for_each_c(const iterator_type_& iter, const size_type_& size)
 {
     typedef size_transformer<plane<0>, size_type_> s_transformer;
     typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;
 
     iterator_type_ it = iter;
     typename s_transformer::size_type new_size;
     typename i_transformer::iterator_type new_it;
     const int n = size.i0;
 
     s_transformer::transform(size, new_size);
 
     for (int i=0; i<n; i++) {
         i_transformer::transform(it, new_it);
         if (!for_each_c(new_it, new_size))
             return false;
         inc<0>(it);
     }
     return true;
 }
 
 
 template<typename iterator_type_, typename function_type_, typename size_type_>
 LITE_INLINE 
 typename detail::enable_if<(
     size_type_::n > 1
     ), bool>::type 
 for_each_c(const iterator_type_& iter, function_type_& func, const size_type_& size)
 {
     typedef size_transformer<plane<0>, size_type_> s_transformer;
     typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;
 
     iterator_type_ it = iter;
     typename s_transformer::size_type new_size;
     typename i_transformer::iterator_type new_it;
     const int n = size.i0;
 
     s_transformer::transform(size, new_size);
 
     for (int i=0; i<n; i++) {
         i_transformer::transform(it, new_it);
         if (!for_each_c(new_it, func, new_size))
             return false;
         inc<0>(it);
     }
     return true;
 }
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* for_each ************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE void for_each(const array<signature_, traits_type_, rep_>& a)
 {
     for_each(a.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE void for_each(array<signature_, traits_type_, rep_>& a)
 {
     for_each(a.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
 LITE_INLINE void for_each(const array<signature_, traits_type_, rep_>& a, function_type_& func)
 {
     for_each(a.begin(), func, a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
 LITE_INLINE void for_each(array<signature_, traits_type_, rep_>& a, function_type_& func)
 {
     for_each(a.begin(), func, a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE bool for_each_c(const array<signature_, traits_type_, rep_>& a)
 {
     return for_each_c(a.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE bool for_each_c(array<signature_, traits_type_, rep_>& a)
 {
     return for_each_c(a.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
 LITE_INLINE bool for_each_c(const array<signature_, traits_type_, rep_>& a, function_type_& func)
 {
     return for_each_c(a.begin(), func, a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
 LITE_INLINE bool for_each_c(array<signature_, traits_type_, rep_>& a, function_type_& func)
 {
     return for_each_c(a.begin(), func, a.size());
 }
 
 /***********************************************************************************************************/
 /* default_array_traits ************************************************************************************/
 /***********************************************************************************************************/
 
 struct default_array_traits
 {
     template<typename signature_>
     struct representation_type
     {
         typedef array_signature_traits<signature_> array_details;
 
         typedef typename detail::type_if<
             (array_details::volume <= 4096 && array_details::is_fixed_size), 
             internal_rep<false>,
             hybrid_rep<false, (array_details::volume <= 64 ? 64 : 1)>
             >::type type;
 
         typedef typename detail::type_if<
             (array_details::volume <= 4096 && array_details::is_fixed_size), 
             internal_rep<false>,
             hybrid_rep<false, (array_details::volume <= 4096 ? 4096 : 1)>
             >::type temporary_type;
 
         typedef typename detail::type_if<
             (array_details::volume <= 4096 && array_details::is_fixed_size), 
             internal_rep<false>,
             hybrid_rep<false, (array_details::volume <= 4096 ? 4096 : 1)>
             >::type fwd_temporary_type;
 
         typedef typename detail::type_if<
             (array_details::volume <= 4096 && array_details::is_fixed_size), 
             internal_rep<true>,
             hybrid_rep<true, (array_details::volume <= 4096 ? 4096 : 1)>
             >::type rev_temporary_type;
     };
 };
 
 /***********************************************************************************************************/
 /* copy ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename src_rep_>
 LITE_INLINE 
 typename array<signature_, traits_type_, src_rep_>::temporary_array
 copy(const array<signature_, traits_type_, src_rep_>& src)
 {
     return src;
 }
 
 /***********************************************************************************************************/
 /* volume **************************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename size_type_>
 int volume(const size_type_& sz);
 
 #else // DOCUMENTATION_ONLY
 
 LITE_INLINE int volume(const pack<>&)
 {
     return 1;
 }
 
 template<
     typename type0_
     >
 LITE_INLINE int 
 volume(
     const pack<
         type0_
     >& size)
 {        
     return size.i0;
     LITE_ARRAY_USE(size);
 }
 
 template<
     typename type0_,
     typename type1_
     >
 LITE_INLINE int 
 volume(
     const pack<
         type0_,
         type1_
     >& size)
 {        
     return size.i0*size.i1;
     LITE_ARRAY_USE(size);
 }
 
 template<
     typename type0_,
     typename type1_,
     typename type2_
     >
 LITE_INLINE int 
 volume(
     const pack<
         type0_,
         type1_,
         type2_
     >& size)
 {        
     return size.i0*size.i1*size.i2;
     LITE_ARRAY_USE(size);
 }
 
 
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* array ***************************************************************************************************/
 /***********************************************************************************************************/
 
 // forward declaration
 template<typename type_>
 class assign;
 
 // forward declaration
 template<typename type_>
 class swapper;
 
 #ifdef DOCUMENTATION_ONLY
 
 template<
     typename signature_, 
     typename traits_type_ = default_array_traits, 
     typename rep_ = typename traits_type_::template representation_type<signature_>::type>
 class array
 {
 public:
     typedef signature_ signature; 
     typedef traits_type_ traits_type; 
     typedef ... value_type; 
     typedef ... iterator; 
     typedef ... const_iterator; 
     typedef ... reference; 
     typedef ... const_reference; 
 
 
     typedef ... temporary_array; 
 
     typedef ... fwd_temporary_array; 
 
     typedef ... rev_temporary_array;
 
     typedef ... size_type;
 
     static const int dimensions = ...; 
 
     static const bool is_reverse = ...; 
 
     array();
 
     array(const array& other);
 
     template<typename other_rep_>
     array(const array<signature_, traits_type_, other_rep_>& other);
 
     explicit array(int n0, ..., int nN);
 
     explicit array(const size_type& size);
 
     array(const value_type& a0, ..., const value_type& aT);
 
     template<typename arg_type0_, ..., typename arg_typeK_>
     array(const arg_type0_& arg0, ..., const arg_typeK_& argK, const size_type& sz);
 
     template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
     array(
         const other_iterator_type_& it, 
         const other_size_type_& sz, 
         const transform_type_& trans);
 
 
     array& operator=(const array& other);
 
     template<typename other_rep_>
     array& operator=(const array<signature_, traits_type_, other_rep_>& other);
 
     const_iterator begin() const;
 
     iterator begin();
 
     size_type size() const;
 
     const_reference operator()(int i0, ..., int iN) const;
 
     reference operator()(int i0, ..., int iN);
 
     const_reference operator[](int i0) const;
 
     reference operator[](int i0);
 
     template<typename transform_type_>
     const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const;
 
     template<typename transform_type_>
     const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans);
 
     const value_type* data() const;
 
     value_type* data();
 
     void resize(int n0, ..., int nN);
 
     void resize(const size_type& sz);
 
     void release();
 };
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* array, reference_rep ************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename iterator_type_>
 class reference_rep {};
 
 
 template<
     typename value_type_,
     typename traits_type_,
     typename iterator_
     >
 class array<
     value_type_,
     traits_type_,
     reference_rep<iterator_>
     >
 {
 public:
     typedef value_type_ signature;
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef iterator_ iterator;
     typedef iterator_ const_iterator;
     typedef typename std::iterator_traits<iterator>::reference reference;
     typedef reference const_reference;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     static const int dimensions = 0;
 
     LITE_INLINE array(const array& other) 
         : m_iterator(other.m_iterator), m_size(other.m_size)
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<
         typename arg_type0_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const size_type& sz)
         : m_iterator(arg0),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const size_type& sz)
         : m_iterator(arg0, arg1),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_,    
         typename arg_type2_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const arg_type2_& arg2,
         const size_type& sz)
         : m_iterator(arg0, arg1, arg2),
           m_size(sz)
     {}
 
 
     template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
     LITE_INLINE array(
         const other_iterator_type_& it, 
         const other_size_type_& sz, 
         const transform_type_& trans)
     {
         iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
             ::transform(trans, it, sz, m_iterator);
 
         size_transformer<transform_type_, other_size_type_>
             ::transform(trans, sz, m_size);
     }
 
     LITE_INLINE const array& operator=(const array& other) const
     {
         typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE const array& operator=(const value_type& value) const
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const iterator& begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE const size_type& size() const
     {
         return m_size;
     }
 
     LITE_INLINE reference 
     operator()() const
     {
         return at(m_iterator);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(m_iterator, m_size, trans);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
 private:
     iterator m_iterator;
     size_type m_size;
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     typename traits_type_,
     typename iterator_
     >
 class array<
     value_type_[n0_],
     traits_type_,
     reference_rep<iterator_>
     >
 {
 public:
     typedef value_type_ signature[n0_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef iterator_ iterator;
     typedef iterator_ const_iterator;
     typedef typename std::iterator_traits<iterator>::reference reference;
     typedef reference const_reference;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     static const int dimensions = 1;
 
     LITE_INLINE array(const array& other) 
         : m_iterator(other.m_iterator), m_size(other.m_size)
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<
         typename arg_type0_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const size_type& sz)
         : m_iterator(arg0),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const size_type& sz)
         : m_iterator(arg0, arg1),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_,    
         typename arg_type2_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const arg_type2_& arg2,
         const size_type& sz)
         : m_iterator(arg0, arg1, arg2),
           m_size(sz)
     {}
 
 
     template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
     LITE_INLINE array(
         const other_iterator_type_& it, 
         const other_size_type_& sz, 
         const transform_type_& trans)
     {
         iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
             ::transform(trans, it, sz, m_iterator);
 
         size_transformer<transform_type_, other_size_type_>
             ::transform(trans, sz, m_size);
     }
 
     LITE_INLINE const array& operator=(const array& other) const
     {
         typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE const array& operator=(const value_type& value) const
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const iterator& begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE const size_type& size() const
     {
         return m_size;
     }
 
     LITE_INLINE reference 
     operator()(int i0) const
     {
         return at(m_iterator, i0);
     }
 
     LITE_INLINE reference 
     operator[](int i0) const
     {
         return at(m_iterator, i0);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(m_iterator, m_size, trans);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
 private:
     iterator m_iterator;
     size_type m_size;
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     typename traits_type_,
     typename iterator_
     >
 class array<
     value_type_[n0_][n1_],
     traits_type_,
     reference_rep<iterator_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef iterator_ iterator;
     typedef iterator_ const_iterator;
     typedef typename std::iterator_traits<iterator>::reference reference;
     typedef reference const_reference;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     static const int dimensions = 2;
 
     LITE_INLINE array(const array& other) 
         : m_iterator(other.m_iterator), m_size(other.m_size)
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<
         typename arg_type0_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const size_type& sz)
         : m_iterator(arg0),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const size_type& sz)
         : m_iterator(arg0, arg1),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_,    
         typename arg_type2_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const arg_type2_& arg2,
         const size_type& sz)
         : m_iterator(arg0, arg1, arg2),
           m_size(sz)
     {}
 
 
     template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
     LITE_INLINE array(
         const other_iterator_type_& it, 
         const other_size_type_& sz, 
         const transform_type_& trans)
     {
         iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
             ::transform(trans, it, sz, m_iterator);
 
         size_transformer<transform_type_, other_size_type_>
             ::transform(trans, sz, m_size);
     }
 
     LITE_INLINE const array& operator=(const array& other) const
     {
         typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE const array& operator=(const value_type& value) const
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const iterator& begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE const size_type& size() const
     {
         return m_size;
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1) const
     {
         return at(m_iterator, i0, i1);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(m_iterator, m_size, trans);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
 private:
     iterator m_iterator;
     size_type m_size;
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename traits_type_,
     typename iterator_
     >
 class array<
     value_type_[n0_][n1_][n2_],
     traits_type_,
     reference_rep<iterator_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_][n2_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef iterator_ iterator;
     typedef iterator_ const_iterator;
     typedef typename std::iterator_traits<iterator>::reference reference;
     typedef reference const_reference;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     static const int dimensions = 3;
 
     LITE_INLINE array(const array& other) 
         : m_iterator(other.m_iterator), m_size(other.m_size)
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<typename other_rep_>
     LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
         : m_iterator(other.begin()), m_size(other.size())
     {}
 
     template<
         typename arg_type0_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const size_type& sz)
         : m_iterator(arg0),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const size_type& sz)
         : m_iterator(arg0, arg1),
           m_size(sz)
     {}
 
     template<
         typename arg_type0_,    
         typename arg_type1_,    
         typename arg_type2_    
         >
     LITE_INLINE array(
         const arg_type0_& arg0,
         const arg_type1_& arg1,
         const arg_type2_& arg2,
         const size_type& sz)
         : m_iterator(arg0, arg1, arg2),
           m_size(sz)
     {}
 
 
     template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
     LITE_INLINE array(
         const other_iterator_type_& it, 
         const other_size_type_& sz, 
         const transform_type_& trans)
     {
         iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
             ::transform(trans, it, sz, m_iterator);
 
         size_transformer<transform_type_, other_size_type_>
             ::transform(trans, sz, m_size);
     }
 
     LITE_INLINE const array& operator=(const array& other) const
     {
         typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE const array& operator=(const value_type& value) const
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const iterator& begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE const size_type& size() const
     {
         return m_size;
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1, int i2) const
     {
         return at(m_iterator, i0, i1, i2);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(m_iterator, m_size, trans);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");
 
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
 private:
     iterator m_iterator;
     size_type m_size;
 };
 
 /***********************************************************************************************************/
 
 
 /***********************************************************************************************************/
 /* array, internal_rep *************************************************************************************/
 /***********************************************************************************************************/
 
 template<bool reversed_>
 class internal_rep {};
 
 // forward declaration
 template<typename type_>
 class swapper;
 
 template<
     typename value_type_,
     typename traits_type_
     >
 class array<
     value_type_,
     traits_type_,
     internal_rep<false>
     >
 {
 public:
     typedef value_type_ signature;
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = false;
     static const int dimensions = 0;
 
     LITE_INLINE array() 
     {}
 
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data, 
             &other.m_data), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data, value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data, 
             &other.m_data), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data, value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()() const
     {
         return m_data;
     }
 
     LITE_INLINE reference 
     operator()() 
     {
         return m_data;
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data;
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data;
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize()
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
 private:
     value_type m_data;
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_],
     traits_type_,
     internal_rep<false>
     >
 {
 public:
     typedef value_type_ signature[n0_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = false;
     static const int dimensions = 1;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0], 
             &other.m_data[0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0], value), size_type());
     }
 
 
     LITE_INLINE array(
         typename detail::type_if<n0_==2, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==3, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==4, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2, 
         const value_type& a3 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
         m_data[3] = a3;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==5, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2, 
         const value_type& a3, 
         const value_type& a4 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
         m_data[3] = a3;
         m_data[4] = a4;
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0], 
             &other.m_data[0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0) const
     {
         return m_data[i0];
     }
 
     LITE_INLINE reference 
     operator()(int i0) 
     {
         return m_data[i0];
     }
 
     LITE_INLINE const_reference 
     operator[](int i0) const
     {
         return m_data[i0];
     }
 
     LITE_INLINE reference 
     operator[](int i0)
     {
         return m_data[i0];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n0_];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_][n1_],
     traits_type_,
     internal_rep<false>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = false;
     static const int dimensions = 2;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int, int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0], 
             &other.m_data[0][0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0], value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0], 
             &other.m_data[0][0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0][0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0][0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1) const
     {
         return m_data[i0][i1];
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1) 
     {
         return m_data[i0][i1];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0][0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0][0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int, int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n0_][n1_];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_][n1_][n2_],
     traits_type_,
     internal_rep<false>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_][n2_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = false;
     static const int dimensions = 3;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int, int, int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0][0], 
             &other.m_data[0][0][0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0][0], 
             &other.m_data[0][0][0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0][0][0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0][0][0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1, int i2) const
     {
         return m_data[i0][i1][i2];
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1, int i2) 
     {
         return m_data[i0][i1][i2];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0][0][0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0][0][0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int, int, int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n0_][n1_][n2_];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     typename traits_type_
     >
 class array<
     value_type_,
     traits_type_,
     internal_rep<true>
     >
 {
 public:
     typedef value_type_ signature;
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = true;
     static const int dimensions = 0;
 
     LITE_INLINE array() 
     {}
 
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data, 
             &other.m_data), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data, value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data, 
             &other.m_data), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data, value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()() const
     {
         return m_data; 
     }
 
     LITE_INLINE reference 
     operator()() 
     {
         return m_data;
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data;
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data;
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize()
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data, other.begin()), size_type());
     }
 
 private:
     value_type m_data;
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_],
     traits_type_,
     internal_rep<true>
     >
 {
 public:
     typedef value_type_ signature[n0_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = true;
     static const int dimensions = 1;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0], 
             &other.m_data[0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0], value), size_type());
     }
 
 
     LITE_INLINE array(
         typename detail::type_if<n0_==2, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==3, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==4, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2, 
         const value_type& a3 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
         m_data[3] = a3;
     }
 
     LITE_INLINE array(
         typename detail::type_if<n0_==5, const value_type&, detail::invalid_argument>::type a0,
         const value_type& a1, 
         const value_type& a2, 
         const value_type& a3, 
         const value_type& a4 
         )
     {
         m_data[0] = a0;
         m_data[1] = a1;
         m_data[2] = a2;
         m_data[3] = a3;
         m_data[4] = a4;
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0], 
             &other.m_data[0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0) const
     {
         return m_data[i0]; 
     }
 
     LITE_INLINE reference 
     operator()(int i0) 
     {
         return m_data[i0];
     }
 
     LITE_INLINE const_reference 
     operator[](int i0) const
     {
         return m_data[i0];
     }
 
     LITE_INLINE reference 
     operator[](int i0)
     {
         return m_data[i0];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n0_];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_][n1_],
     traits_type_,
     internal_rep<true>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = true;
     static const int dimensions = 2;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int, int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0], 
             &other.m_data[0][0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0], value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0], 
             &other.m_data[0][0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0][0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0][0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1) const
     {
         return m_data[i1][i0]; 
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1) 
     {
         return m_data[i1][i0];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0][0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0][0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int, int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n1_][n0_];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename traits_type_
     >
 class array<
     value_type_[n0_][n1_][n2_],
     traits_type_,
     internal_rep<true>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_][n2_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const bool is_reverse = true;
     static const int dimensions = 3;
 
     LITE_INLINE array() 
     {}
 
     explicit LITE_INLINE array(int, int, int)
     {}
 
     explicit LITE_INLINE array(const size_type&)
     {}
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0][0], 
             &other.m_data[0][0][0]), 
             size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], value), size_type());
     }
 
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         for_each(iterator_type(
             &m_data[0][0][0], 
             &other.m_data[0][0][0]), 
             size_type());
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], value), size_type());
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return const_iterator(&m_data[0][0][0]);
     }
 
     LITE_INLINE iterator begin()
     {
         return iterator(&m_data[0][0][0]);
     }
 
     LITE_INLINE size_type size() const
     {
         return size_type();
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1, int i2) const
     {
         return m_data[i2][i1][i0]; 
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1, int i2) 
     {
         return m_data[i2][i1][i0];
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return &m_data[0][0][0];
     }
 
     LITE_INLINE value_type* data()
     {
         return &m_data[0][0][0];
     }
 
     LITE_INLINE void release() 
     {}
 
     LITE_INLINE void resize(int, int, int)
     {}
 
     LITE_INLINE void resize(const size_type&)
     {}
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::iterator, 
             swapper<value_type> > 
             iterator_type;
 
         for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
     }
 
 private:
     value_type m_data[n2_][n1_][n0_];
 };
 
 /***********************************************************************************************************/
 
 
 /***********************************************************************************************************/
 /* array, hybrid_rep ***************************************************************************************/
 /***********************************************************************************************************/
 
 template<bool reversed_, int internal_buf_size_>
 class hybrid_rep 
 {};
 
 
 template<
     typename value_type_,
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_,
     traits_type_,
     hybrid_rep<false, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature;
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 0;
     static const bool is_reverse = false;
     static const int internal_buffer_size = internal_buf_size_;
 
 
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()() const
     {
         return *(m_iterator.i0);
     }
 
     LITE_INLINE reference 
     operator()() 
     {
         return *(m_iterator.i0);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set();
     }
 
     LITE_INLINE void resize()
     {
         resize(size_type());
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set();
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set();
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_],
     traits_type_,
     hybrid_rep<false, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 1;
     static const bool is_reverse = false;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0)
     {
         init();
         resize(size_type(n0));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE reference 
     operator()(int i0) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE const_reference 
     operator[](int i0) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE reference 
     operator[](int i0)
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0);
     }
 
     LITE_INLINE void resize(int n0)
     {
         resize(size_type(n0));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             1
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_][n1_],
     traits_type_,
     hybrid_rep<false, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 2;
     static const bool is_reverse = false;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0, int n1)
     {
         init();
         resize(size_type(n0, n1));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0, 0);
     }
 
     LITE_INLINE void resize(int n0, int n1)
     {
         resize(size_type(n0, n1));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0, 0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             m_size.i1,
             1
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0, 0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_][n1_][n2_],
     traits_type_,
     hybrid_rep<false, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_][n2_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 3;
     static const bool is_reverse = false;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0, int n1, int n2)
     {
         init();
         resize(size_type(n0, n1, n2));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1, int i2) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1, int i2) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0, 0, 0);
     }
 
     LITE_INLINE void resize(int n0, int n1, int n2)
     {
         resize(size_type(n0, n1, n2));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0, 0, 0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             m_size.i1*m_size.i2,
             m_size.i2,
             1
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0, 0, 0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_,
     traits_type_,
     hybrid_rep<true, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature;
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 0;
     static const bool is_reverse = true;
     static const int internal_buffer_size = internal_buf_size_;
 
 
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()() const
     {
         return *(m_iterator.i0);
     }
 
     LITE_INLINE reference 
     operator()() 
     {
         return *(m_iterator.i0);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set();
     }
 
     LITE_INLINE void resize()
     {
         resize(size_type());
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set();
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set();
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_],
     traits_type_,
     hybrid_rep<true, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 1;
     static const bool is_reverse = true;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0)
     {
         init();
         resize(size_type(n0));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE reference 
     operator()(int i0) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE const_reference 
     operator[](int i0) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
     LITE_INLINE reference 
     operator[](int i0)
     {
         return *(m_iterator.i0+i0*m_iterator.i1);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0);
     }
 
     LITE_INLINE void resize(int n0)
     {
         resize(size_type(n0));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             1
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_][n1_],
     traits_type_,
     hybrid_rep<true, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 2;
     static const bool is_reverse = true;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0, int n1)
     {
         init();
         resize(size_type(n0, n1));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0, 0);
     }
 
     LITE_INLINE void resize(int n0, int n1)
     {
         resize(size_type(n0, n1));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0, 0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             1,
             m_size.i0
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0, 0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 template<
     typename value_type_,
     int n0_, 
     int n1_, 
     int n2_, 
     typename traits_type_,
     int internal_buf_size_
     >
 class array<
     value_type_[n0_][n1_][n2_],
     traits_type_,
     hybrid_rep<true, internal_buf_size_>
     >
 {
 public:
     typedef value_type_ signature[n0_][n1_][n2_];
     typedef traits_type_ traits_type;
     typedef value_type_ value_type;
     typedef const value_type_& const_reference;
     typedef value_type_& reference;
 
     typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
     typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
     typedef typename array_signature_traits<signature>::size_type size_type;
 
     typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;
 
     static const int dimensions = 3;
     static const bool is_reverse = true;
     static const int internal_buffer_size = internal_buf_size_;
 
     LITE_INLINE array() 
     {
         init();
         resize(size_type());
     }
 
     explicit LITE_INLINE array(int n0, int n1, int n2)
     {
         init();
         resize(size_type(n0, n1, n2));
     }
 
     explicit LITE_INLINE array(const size_type& sz)
     {
         init();
         resize(sz);
     }
 
     LITE_INLINE array(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
     }
 
     template<typename other_rep_>
     LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         init();
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
     }
 
     LITE_INLINE array(const value_type& value) 
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         init();
         for_each(iterator_type(m_iterator, value), m_size);
     }
 
     LITE_INLINE array& operator=(const array& other) 
     {
         typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.m_iterator), m_size);
         return *this;
     }
 
     template<typename other_rep_>
     LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
     {
         typedef b_iterator<
             iterator, 
             typename array<signature, traits_type_, other_rep_>::const_iterator, 
             assign<value_type> > 
             iterator_type;
 
         resize(other.size());
         for_each(iterator_type(m_iterator, other.begin()), m_size);
         return *this;
     }
 
     LITE_INLINE array& operator=(const value_type& value)
     {
         typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;
 
         for_each(iterator_type(m_iterator, value), m_size);
         return *this;
     }
 
     LITE_INLINE const_iterator begin() const
     {
         return m_iterator;
     }
 
     LITE_INLINE iterator begin()
     {
         return m_iterator;
     }
 
     LITE_INLINE size_type size() const
     {
         return m_size;
     }
 
     LITE_INLINE const_reference 
     operator()(int i0, int i1, int i2) const
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
     }
 
     LITE_INLINE reference 
     operator()(int i0, int i1, int i2) 
     {
         return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
     }
 
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
     operator[](const transform_type_& trans) const
     {
         typedef typename transform_traits<array, transform_type_>::const_array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     template<typename transform_type_>
     LITE_INLINE const typename transform_traits<array, transform_type_>::array
     operator[](const transform_type_& trans)
     {
         typedef typename transform_traits<array, transform_type_>::array result_type;
 
         return result_type(begin(), size(), trans);
     }
 
     LITE_INLINE const value_type* data() const
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE value_type* data()
     {
         return m_iterator.i0;
     }
 
     LITE_INLINE void release() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
 
         m_iterator.i0 = 0;
         m_size.set(0, 0, 0);
     }
 
     LITE_INLINE void resize(int n0, int n1, int n2)
     {
         resize(size_type(n0, n1, n2));
     }
 
     LITE_INLINE void resize(const size_type& new_size)
     {
         int old_volumne = volume(m_size);
         int new_volume = volume(new_size);
 
         if (old_volumne != new_volume || m_iterator.i0==0) {
             if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                 delete[] m_iterator.i0;
             m_iterator.i0 = 0;
             m_size.set(0, 0, 0);
 
             if (new_volume == 0)
                 return;
 
             m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
         }
         m_size = new_size;
         m_iterator.set(
             m_iterator.i0,
             1,
             m_size.i0,
             m_size.i0*m_size.i1
         );
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     template<typename other_rep_>
     LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
     {
         regular_swap(other);
     }
 
     LITE_INLINE void swap(array& other)
     {
         // fast swap
         if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
             iterator tmp_iter = other.m_iterator;
             size_type tmp_size = other.m_size;
 
             other.m_iterator = m_iterator;
             other.m_size = m_size;
 
             m_iterator = tmp_iter;
             m_size = tmp_size;
         }
         else
             regular_swap(other);
     }
 
 
     LITE_INLINE ~array() 
     {
         if (m_iterator.i0 && m_iterator.i0 != m_buffer)
             delete[] m_iterator.i0;
     }
 
 private:
 
     template<typename other_array_>
     LITE_INLINE void regular_swap(other_array_& other)
     {
         typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;
 
         if (m_size == other.size()) 
             for_each(iterator_type(m_iterator, other.begin()), m_size);
         else {
             typename other_array_::temporary_array tmp = other;
 
             other = *this;
             *this = tmp;
         }
     }
 
     //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
     //friend class array;
 
     LITE_INLINE void init()
     {
         m_iterator.i0 = 0;
         m_size.set(0, 0, 0);
         resize(m_size);
     }
 
     iterator m_iterator;
     size_type m_size;
     value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
 };
 
 /***********************************************************************************************************/
 
 
 /***********************************************************************************************************/
 /* transform_traits ****************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename array_type_, typename trans_type_>
 struct transform_traits
 {
     typedef typename size_transformer<trans_type_, typename array_type_::size_type>::size_type size_type;
 
     typedef typename detail::size_to_signature<size_type, typename array_type_::value_type>::type signature;
 
     typedef typename array_type_::traits_type traits_type;
 
     typedef typename iterator_transformer<
         trans_type_, 
         typename array_type_::iterator, 
         typename array_type_::size_type>::iterator_type iterator;
 
     typedef typename iterator_transformer<
         trans_type_, 
         typename array_type_::const_iterator, 
         typename array_type_::size_type>::iterator_type const_iterator;
 
     typedef ::lite::array<signature, traits_type, reference_rep<iterator> > array;
     
     typedef ::lite::array<signature, traits_type, reference_rep<const_iterator> > const_array;
 
     typedef typename array_helper<signature, traits_type>::temporary_array temporary_array;
 
     typedef typename array_helper<signature, traits_type>::fwd_temporary_array fwd_temporary_array;
 
     typedef typename array_helper<signature, traits_type>::rev_temporary_array rev_temporary_array;
 };
 
 #else // DOCUMENTATION_ONLY
 
 template<typename array_type_, typename trans_type_>
 struct transform_traits<
     array_type_, 
     trans_type_, 
     typename detail::enable_if<
         detail::defined<typename size_transformer<trans_type_, 
             typename array_type_::size_type>::size_type>::value
         >::type
     >
 {
     typedef typename size_transformer<trans_type_, typename array_type_::size_type>::size_type size_type;
     typedef typename detail::size_to_signature<size_type, typename array_type_::value_type>::type signature;
     typedef typename array_type_::traits_type traits_type;
 
     typedef typename iterator_transformer<
         trans_type_, 
         typename array_type_::iterator, 
         typename array_type_::size_type>::iterator_type iterator;
 
     typedef typename iterator_transformer<
         trans_type_, 
         typename array_type_::const_iterator, 
         typename array_type_::size_type>::iterator_type const_iterator;
 
     typedef ::lite::array<signature, traits_type, reference_rep<iterator> > array;
     typedef ::lite::array<signature, traits_type, reference_rep<const_iterator> > const_array;
 
     typedef typename array_helper<signature, traits_type>::temporary_array temporary_array;
     typedef typename array_helper<signature, traits_type>::fwd_temporary_array fwd_temporary_array;
     typedef typename array_helper<signature, traits_type>::rev_temporary_array rev_temporary_array;
 };
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* function objects ****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename type_>
 class uplus
 { 
 public: 
     typedef type_ argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const argument_type& a) const 
     { return +a; } 
 };
 
 template<typename type_>
 class negate
 { 
 public: 
     typedef type_ argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const argument_type& a) const 
     { return -a; } 
 };
 
 template<typename type_>
 class plus
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a + b; } 
 };
 
 template<typename type_>
 class minus
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a - b; } 
 };
 
 template<typename type_>
 class multiplies
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a*b; } 
 };
 
 template<typename type_>
 class divides
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a/b; } 
 };
 
 template<typename type_>
 class assign
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_& result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
     { return a = b; } 
 };
 
 template<typename type_>
 class plus_assign
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_& result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
     { return a += b; } 
 };
 
 template<typename type_>
 class minus_assign
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_& result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
     { return a -= b; } 
 };
 
 template<typename type_>
 class multiplies_assign
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_& result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
     { return a *= b; } 
 };
 
 template<typename type_>
 class divides_assign
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef type_& result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
     { return a /= b; } 
 };
 
 template<typename type_>
 class minimum
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef const type_& result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a < b ? a : b; } 
 };
 
 template<typename type_>
 class maximum
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef const type_& result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a > b ? a : b; } 
 };
 
 template<typename type_>
 class square
 { 
 public: 
     typedef type_ argument_type;
     typedef type_ result_type;
 
     LITE_INLINE result_type operator()(const argument_type& a) const 
     { return a*a; } 
 };
 
 template<typename type_>
 class less
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a < b; } 
 };
 
 template<typename type_>
 class less_equal
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a <= b; } 
 };
 
 template<typename type_>
 class equal_to
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a == b; } 
 };
 
 template<typename type_>
 class greater_equal
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a >= b; } 
 };
 
 template<typename type_>
 class greater
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a > b; } 
 };
 
 template<typename type_>
 class compare3
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef int result_type;
 
     LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
     { return a < b ? -1 : b < a ? 1 : 0; } 
 };
 
 template<typename type_>
 class round
 { 
 public: 
     typedef type_ argument_type;
     typedef type_ result_type;
 
     round(const type_& normal = type_(1)) : m_normal(normal) {}
 
     LITE_INLINE result_type operator()(const argument_type& a) const 
     { return (a+m_normal)-m_normal; } 
 
 private:
     type_ m_normal;
 };
 
 template<typename type_>
 class accumulator
 { 
 public: 
     typedef type_ argument_type;
     typedef void result_type;
 
     LITE_INLINE accumulator(const type_& value = type_()) 
         : m_value(value) 
     {}
 
     LITE_INLINE accumulator(const accumulator& other) 
         : m_value(other.m_value) 
     {}
 
     LITE_INLINE accumulator& operator=(const accumulator& other)
     {
         m_value = other.m_value;
         return *this;
     }
 
     LITE_INLINE void operator()(const argument_type& a) 
     { 
         m_value += a;
     }
 
     LITE_INLINE type_ operator()() const
     { 
         return m_value;
     }
 
 private:
     type_ m_value;
 };
 
 template<typename type_>
 class while_equal
 { 
 public: 
     typedef type_ argument_type;
     typedef bool result_type;
 
     LITE_INLINE while_equal(): m_result() {}
 
     LITE_INLINE while_equal(const while_equal& other) : m_result(other.m_result) {}
 
     LITE_INLINE while_equal& operator=(const while_equal& other) 
     { 
         m_result = other.m_result;
         return *this; 
     }
 
     LITE_INLINE result_type operator()(const argument_type& a) 
     { 
         if (a == 0)
             return true;
 
         m_result = a;
         return false;
     }
     
     LITE_INLINE argument_type operator()() const
     {
         return m_result;
     }
 
 private:
     argument_type m_result;
 };
 
 
 template<typename type_>
 class swapper
 { 
 public: 
     typedef type_ first_argument_type;
     typedef type_ second_argument_type;
     typedef bool result_type;
 
     LITE_INLINE result_type operator()(first_argument_type& a, second_argument_type& b) const 
     { 
         std::swap(a, b);
         return true; 
     } 
 };
 
 /***********************************************************************************************************/
 /* apply<F>(A) *********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     func_type_>
     > >
 apply(const array<signature_, traits_type_, rep_>& a)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         func_type_> > 
     > result_type;
 
     return result_type(a.begin(), a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::iterator,
     func_type_>
     > >
 apply(array<signature_, traits_type_, rep_>& a)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::iterator,
         func_type_> > 
     > result_type;
 
     return result_type(a.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* apply(A,f) **********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     func_type_,
     false>
     > >
 apply(const array<signature_, traits_type_, rep_>& a, const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         func_type_,
         false> > 
     > result_type;
 
     return result_type(a.begin(), func, a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::iterator,
     func_type_,
     false>
     > >
 apply(array<signature_, traits_type_, rep_>& a, const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::iterator,
         func_type_,
         false> > 
     > result_type;
 
     return result_type(a.begin(), func, a.size());
 }
 
 
 /***********************************************************************************************************/
 /* apply<F>(A,A) *******************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     func_type_>
     > >
 apply(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         func_type_
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     func_type_>
     > >
 apply(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         func_type_
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::iterator,
     func_type_>
     > >
 apply(const array<signature_, traits_type_, l_rep_>& a, array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::iterator,
         func_type_
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::iterator,
     typename array<signature_,traits_type_, r_rep_>::iterator,
     func_type_>
     > >
 apply(array<signature_, traits_type_, l_rep_>& a, array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::iterator,
         func_type_
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* apply(A,A,f) ********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     func_type_>
     > >
 apply(
     const array<signature_, traits_type_, l_rep_>& a, 
     const array<signature_, traits_type_, r_rep_>& b,
     const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         func_type_,
         false
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
     return result_type(a.begin(), b.begin(), func, a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     func_type_>
     > >
 apply(
     array<signature_, traits_type_, l_rep_>& a, 
     const array<signature_, traits_type_, r_rep_>& b,
     const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         func_type_,
         false
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
     return result_type(a.begin(), b.begin(), func, a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::iterator,
     func_type_>
     > >
 apply(
     const array<signature_, traits_type_, l_rep_>& a, 
     array<signature_, traits_type_, r_rep_>& b,
     const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::iterator,
         func_type_,
         false
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
     return result_type(a.begin(), b.begin(), func, a.size());
 }
 
 template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::iterator,
     typename array<signature_,traits_type_, r_rep_>::iterator,
     func_type_>
     > >
 apply(
     array<signature_, traits_type_, l_rep_>& a, 
     array<signature_, traits_type_, r_rep_>& b,
     const func_type_& func)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::iterator,
         func_type_,
         false
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
     return result_type(a.begin(), b.begin(), func, a.size());
 }
 
 /***********************************************************************************************************/
 /* +A ******************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     uplus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator+(const array<signature_, traits_type_, rep_>& a)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         uplus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* -A ******************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     negate<typename array_signature_traits<signature_>::element_type>
     > > >
 operator-(const array<signature_, traits_type_, rep_>& a)
 {
     typedef array<signature_, traits_type_, reference_rep<u_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         negate<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* A+c *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     plus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator+(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         plus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), b, a.size());
 }
 
 /***********************************************************************************************************/
 /* c+A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     plus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator+(
     const typename array_signature_traits<signature_>::element_type& a, 
     const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         plus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a, b.begin(), b.size());
 }
 
 /***********************************************************************************************************/
 /* A-c *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     minus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator-(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         minus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), b, a.size());
 }
 
 /***********************************************************************************************************/
 /* c-A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     minus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator-(
     const typename array_signature_traits<signature_>::element_type& a, 
     const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         minus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a, b.begin(), b.size());
 }
 
 
 /***********************************************************************************************************/
 /* A*c *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     multiplies<typename array_signature_traits<signature_>::element_type>
     > > >
 operator*(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         multiplies<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), b, a.size());
 }
 
 /***********************************************************************************************************/
 /* c*A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     multiplies<typename array_signature_traits<signature_>::element_type>
     > > >
 operator*(
     const typename array_signature_traits<signature_>::element_type& a, 
     const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         multiplies<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a, b.begin(), b.size());
 }
 
 /***********************************************************************************************************/
 /* A/c *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     c_iterator<typename array_signature_traits<signature_>::element_type>,
     divides<typename array_signature_traits<signature_>::element_type>
     > > >
 operator/(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         divides<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     return result_type(a.begin(), b, a.size());
 }
 
 
 /***********************************************************************************************************/
 /* A+A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     plus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator+(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         plus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* A-A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     minus<typename array_signature_traits<signature_>::element_type>
     > > >
 operator-(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         minus<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* A|A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     multiplies<typename array_signature_traits<signature_>::element_type>
     > > >
 operator|(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         multiplies<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|(A,A): array sizes do not match");
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* A+=c ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator+=(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         plus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator+=(
     array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         plus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A-=c ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator-=(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         minus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator-=(
     array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         minus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A*=c ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator*=(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         multiplies_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator*=(
     array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         multiplies_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A/=c ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator/=(
     const array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         divides_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator/=(
     array<signature_, traits_type_, l_rep_>& a, 
     const typename array_signature_traits<signature_>::element_type& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         c_iterator<typename array_signature_traits<signature_>::element_type>,
         divides_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     for_each(iterator_type(a.begin(), b), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A+=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator+=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         plus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator+=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         plus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A-=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator-=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         minus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator-=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         minus_assign<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A|=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, l_rep_>&
 operator|=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         multiplies_assign<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, l_rep_>&
 operator|=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         multiplies_assign<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|=(A,A): array sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), a.size());
     return a;
 }
 
 /***********************************************************************************************************/
 /* A<A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator<(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         less<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator<(A,A): array sizes do not match");
     return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
 }
 
 /***********************************************************************************************************/
 /* A<=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator<=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         less_equal<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator<=(A,A): array sizes do not match");
     return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
 }
 
 /***********************************************************************************************************/
 /* A==A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator==(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         equal_to<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator==(A,A): array sizes do not match");
     return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
 }
 
 /***********************************************************************************************************/
 /* A!=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator!=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     return !(a==b);
 }
 
 /***********************************************************************************************************/
 /* A>=A ****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator>=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         greater_equal<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator>=(A,A): array sizes do not match");
     return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
 }
 
 /***********************************************************************************************************/
 /* A>A *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE bool 
 operator>(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         greater<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator>(A,A): array sizes do not match");
     return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
 }
 
 /***********************************************************************************************************/
 /* compare(A,A) ********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE int
 compare(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         compare3<typename array_signature_traits<signature_>::element_type>
         > iterator_type;
 
     while_equal<typename compare3<
         typename array_signature_traits<signature_>::element_type>::result_type> func;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "compare(A,A): array sizes do not match");
     for_each_c(iterator_type(a.begin(), b.begin()), func, a.size());
     return func();
 }
 
 /***********************************************************************************************************/
 /* norm(A) *************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE typename array_signature_traits<signature_>::element_type 
 norm(const array<signature_, traits_type_, rep_>& a)
 {
     typedef u_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         square<typename array_signature_traits<signature_>::element_type>
     > iterator_type;
 
     accumulator<typename array_signature_traits<signature_>::element_type> acc;
 
     for_each(iterator_type(a.begin()), acc, a.size());
     return acc();
 }
 
 /***********************************************************************************************************/
 /* normalized(A) *******************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE const typename array_helper<signature_, traits_type_>::temporary_array
 normalized(const array<signature_, traits_type_, rep_>& a)
 {
     typedef array<signature_, traits_type_, rep_> a_type;
     typedef typename array_helper<signature_, traits_type_>::temporary_array result_type;
     typedef typename array_signature_traits<signature_>::element_type value_type;
     typedef u_iterator<typename result_type::iterator, square<value_type> > iterator_type;
 
     result_type result = a;
     accumulator<value_type> acc;
 
     for_each(iterator_type(result.begin()), acc, result.size());
     result *= value_type(1)/sqrt(acc());
     return result;
 }
 
 /***********************************************************************************************************/
 /* abs(A) **************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE typename array_signature_traits<signature_>::element_type 
 abs(const array<signature_, traits_type_, rep_>& a)
 {
     return sqrt(norm(a));
 }
 
 /***********************************************************************************************************/
 /* min(A,A) ************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     minimum<typename array_signature_traits<signature_>::element_type>
     > > >
 min(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         minimum<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "min(A,A): array sizes do not match");
 
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     typename array<signature_,traits_type_, rep_>::const_iterator,
     minimum<typename array_signature_traits<signature_>::element_type>
     > > >
 min(const array<signature_, traits_type_, rep_>& a, const array<signature_, traits_type_, rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         typename array<signature_,traits_type_, rep_>::const_iterator,
         minimum<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "min(A,A): array sizes do not match");
 
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* max(A,A) ************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, l_rep_>::const_iterator,
     typename array<signature_,traits_type_, r_rep_>::const_iterator,
     maximum<typename array_signature_traits<signature_>::element_type>
     > > >
 max(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, l_rep_>::const_iterator,
         typename array<signature_,traits_type_, r_rep_>::const_iterator,
         maximum<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "max(A,A): array sizes do not match");
 
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE 
 array<signature_, traits_type_, reference_rep<b_iterator<
     typename array<signature_,traits_type_, rep_>::const_iterator,
     typename array<signature_,traits_type_, rep_>::const_iterator,
     maximum<typename array_signature_traits<signature_>::element_type>
     > > >
 max(const array<signature_, traits_type_, rep_>& a, const array<signature_, traits_type_, rep_>& b)
 {
     typedef array<signature_, traits_type_, reference_rep<b_iterator<
         typename array<signature_,traits_type_, rep_>::const_iterator,
         typename array<signature_,traits_type_, rep_>::const_iterator,
         maximum<typename array_signature_traits<signature_>::element_type>
         > > > result_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "max(A,A): array sizes do not match");
 
     return result_type(a.begin(), b.begin(), a.size());
 }
 
 /***********************************************************************************************************/
 /* V*V *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<(array_signature_traits<value_type_>::dimensions == 0), value_type_>::type
 operator*(
     const array<value_type_[n_], traits_type_, l_rep_>& a, 
     const array<value_type_[n_], traits_type_, r_rep_>& b)
 {
     typedef b_iterator<
         typename array<value_type_[n_],traits_type_, l_rep_>::const_iterator,
         typename array<value_type_[n_],traits_type_, r_rep_>::const_iterator,
         multiplies<value_type_>
         > iterator_type;
 
     accumulator<value_type_> acc;
 
     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator*(V,V): vector sizes do not match");
     for_each(iterator_type(a.begin(), b.begin()), acc, a.size());
     return acc();
 }
 
 /***********************************************************************************************************/
 /* M*V *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, int m_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<
     (array_signature_traits<value_type_>::dimensions == 0), 
     const typename array_helper<value_type_[m_], traits_type_>::temporary_array
     >::type
 operator*(
     const array<value_type_[m_][n_], traits_type_, l_rep_>& a, 
     const array<value_type_[n_], traits_type_, r_rep_>& b)
 {
     typedef array<value_type_[m_][n_], traits_type_, l_rep_> a_type;
     typedef array<value_type_[n_], traits_type_, r_rep_> b_type;
     typedef typename array_helper<value_type_[m_], traits_type_>::temporary_array result_type;
     typedef typename result_type::size_type size_type;
 
     typename detail::matrix_policy<a_type, 1> ::cached_fwd_array aa = a;
     typename detail::matrix_policy<b_type, 9> ::cached_array bb = b;
 
     const int m = aa.size().i0;
 
     const size_type size(m);
     result_type result(size);
 
     LITE_ARRAY_SIZE_CHECK(aa.size().i1, b.size().i0, "operator*(M,V): matrix/vector sizes do not match");
 
     for (int i=0; i<m; i++)
         result[i] = aa[row(i)]*bb;
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* V*M *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, int m_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<
     (array_signature_traits<value_type_>::dimensions == 0), 
     const typename array_helper<value_type_[n_], traits_type_>::temporary_array
     >::type
 operator*(
     const array<value_type_[m_], traits_type_, l_rep_>& a,
     const array<value_type_[m_][n_], traits_type_, r_rep_>& b)
 {
     typedef array<value_type_[m_], traits_type_, l_rep_> a_type;
     typedef array<value_type_[m_][n_], traits_type_, r_rep_> b_type;
     typedef typename array_helper<value_type_[n_], traits_type_>::temporary_array result_type;
     typedef typename result_type::size_type size_type;
 
     typename detail::matrix_policy<a_type, 9>::cached_array aa = a;
     typename detail::matrix_policy<b_type, 1>::cached_rev_array bb = b;
 
     const int n = bb.size().i1;
 
     const size_type size(n);
     result_type result(size);
 
     LITE_ARRAY_SIZE_CHECK(aa.size().i0, bb.size().i0, "operator*(V,M): matrix/vector sizes do not match");
 
     for (int j=0; j<n; j++)
         result[j] = aa*bb[column(j)];
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* M*M *****************************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename value_type_, 
     int m_, 
     int n_, 
     int p_, 
     typename traits_type_, 
     typename l_rep_, 
     typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<
     (array_signature_traits<value_type_>::dimensions == 0), 
     const typename array_helper<value_type_[m_][p_], traits_type_>::temporary_array
     >::type
 operator*(
     const array<value_type_[m_][n_], traits_type_, l_rep_>& a,
     const array<value_type_[n_][p_], traits_type_, r_rep_>& b)
 {
     typedef array<value_type_[m_][n_], traits_type_, l_rep_> a_type;
     typedef array<value_type_[n_][p_], traits_type_, r_rep_> b_type;
     typedef typename array_helper<value_type_[m_][p_], traits_type_>::temporary_array result_type;
     typedef typename result_type::size_type size_type;
 
     typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;
     typename detail::matrix_policy<b_type, 9>::cached_rev_array bb = b;
 
     const int m = aa.size().i0;
     const int p = bb.size().i1;
 
     const size_type size(m, p);
     result_type result(size);
 
     LITE_ARRAY_SIZE_CHECK(aa.size().i1, bb.size().i0, "operator*(M,M): matrix sizes do not match");
 
     for (int i=0; i<m; i++)
         for (int j=0; j<p; j++)
             result(i,j) = aa[row(i)]*bb[column(j)];
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* V%V, 2D (cross product) *********************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     value_type_
     >::type
 operator%(
     const array<value_type_[2], traits_type_, l_rep_>& a, 
     const array<value_type_[2], traits_type_, r_rep_>& b)
 {
     return a[0]*b[1]-a[1]*b[0];
 }
 
 /***********************************************************************************************************/
 /* V%V, 3D (cross product) *********************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[3], traits_type_>::temporary_array
     >::type
 operator%(
     const array<value_type_[3], traits_type_, l_rep_>& a, 
     const array<value_type_[3], traits_type_, r_rep_>& b)
 {
     typedef array<value_type_[3], traits_type_, l_rep_> a_type;
     typedef array<value_type_[3], traits_type_, r_rep_> b_type;
     typedef typename array_helper<value_type_[3], traits_type_>::temporary_array result_type;
 
     typename detail::matrix_policy<a_type, 9>::cached_array aa = a;
     typename detail::matrix_policy<b_type, 9>::cached_array bb = b;
 
     return result_type(aa[1]*bb[2]-aa[2]*bb[1], aa[2]*bb[0]-aa[0]*bb[2], aa[0]*bb[1]-aa[1]*bb[0]);
 }
 
 /***********************************************************************************************************/
 /* determinant, 2D *****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     value_type_
     >::type
 det(const array<value_type_[2][2], traits_type_, rep_>& a)
 {
     return a(0, 0)*a(1, 1) - a(0, 1)*a(1, 0);
 }
 
 /***********************************************************************************************************/
 /* determinant, 3D *****************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     value_type_
     >::type
 det(const array<value_type_[3][3], traits_type_, rep_>& a)
 {
     typedef array<value_type_[3][3], traits_type_, rep_> a_type;
     typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;
 
     value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
     value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
     value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
     return aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20;
 }
 
 /***********************************************************************************************************/
 /* determinant, nD *****************************************************************************************/
 /***********************************************************************************************************/
 
 // uses Gaussian upper triangulation
 template<typename value_type_, int n_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     value_type_
     >::type
 det(const array<value_type_[n_][n_], traits_type_, rep_>& a)
 {
     using std::abs;
 
     typedef typename array_helper<value_type_[n_][n_], traits_type_>::fwd_temporary_array temporary_type;
     typedef array<value_type_[n_][n_], traits_type_, rep_> a_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, "det(M): not a square matrix");
 
     temporary_type aa = a;
     const int n = aa.size().i0;
     int swaps = 0;
 
     for (int i=0; i<n; i++) {
         const block<0,1> blk(0, n-i);
         int i_max = i;
         value_type_ val_max = abs(aa(i, i));
 
         // find the strongest row
         for (int i2 = i+1; i2<n; i2++)
             if (abs(aa(i2, i)) > val_max) {
                 i_max = i2;
                 val_max = abs(aa(i2, i));
             }
 
         // swap row i_max with row i
         if (i_max != i) {
             typename transform_traits<temporary_type, block<0,1> >::temporary_array tmp_row;
 
             tmp_row = aa[blk(i, i)];
             aa[blk(i, i)] = aa[blk(i_max, i)];
             aa[blk(i_max, i)] = tmp_row;
             swaps++;
         }
 
         // if a singular matrix return a zero matrix
         if (aa(i, i) == value_type_())
             return value_type_();
 
         value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;
         value_type_ factor = value_type_(1)/aa(i, i);
 
         // simplify the column in the lower triangle
         for (int i2 = i+1; i2<n; i2++) 
             if (abs(aa(i2, i)) > epsilon)
                 aa[blk(i2, i)] -= (aa(i2, i)*factor)*aa[blk(i, i)];
     }
 
     value_type_ result = value_type_(1);
 
     for (int i=0; i<n; i++)
         result *= aa(i, i);
 
     return (swaps & 1) != 0 ? -result : result;
 }
 
 /***********************************************************************************************************/
 /* inverse, 2D *********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
     >::type
 inverse(const array<value_type_[2][2], traits_type_, rep_>& a)
 {
     typedef array<value_type_[2][2], traits_type_, rep_> a_type;
     typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;
 
     typename array_helper<value_type_[2][2], traits_type_>::temporary_array result;
 
     value_type_ inv_det = value_type_(1)/(aa(0, 0)*aa(1, 1) - aa(0, 1)*a(1, 0));
 
     result(0, 0) = aa(1, 1) * inv_det;
     result(0, 1) = -aa(0, 1) * inv_det;
     result(0, 2) = -aa(1, 0) * inv_det;
     result(0, 3) = aa(0, 0) * inv_det;
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* inverse, 3D *********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
     >::type
 inverse(const array<value_type_[3][3], traits_type_, rep_>& a)
 {
     typedef array<value_type_[3][3], traits_type_, rep_> a_type;
     typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;
 
     typename array_helper<value_type_[3][3], traits_type_>::temporary_array result;
     
     value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
     value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
     value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
     value_type_ inv_det = value_type_(1)/(aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20);
 
     result(0, 0) = det00*inv_det; 
     result(0, 1) = -det10*inv_det; 
     result(0, 2) = det20*inv_det;
     result(1, 0) = (aa(2, 0)*aa(1, 2)-aa(2, 2)*aa(1, 0))*inv_det; 
     result(1, 1) = (aa(2, 2)*aa(0, 0)-aa(2, 0)*aa(0, 2))*inv_det;
     result(1, 2) = (aa(1, 0)*aa(0, 2)-aa(1, 2)*aa(0, 0))*inv_det;
     result(2, 0) = (aa(2, 1)*aa(1, 0)-aa(2, 0)*aa(1, 1))*inv_det;
     result(2, 1) = (aa(2, 0)*aa(0, 1)-aa(2, 1)*aa(0, 0))*inv_det;
     result(2, 2) = (aa(1, 1)*aa(0, 0)-aa(1, 0)*aa(0, 1))*inv_det;
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* inverse, nD *********************************************************************************************/
 /***********************************************************************************************************/
 
 // uses Gauss-Jordan elimination
 template<typename value_type_, int n_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array
     >::type
 inverse(const array<value_type_[n_][n_], traits_type_, rep_>& a)
 {
     using std::abs;
 
     typedef array<value_type_[n_][n_], traits_type_, rep_> a_type;
     typedef typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array temporary_type;
 
     LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, "inverse(M): not a square matrix");
 
     const int n = a.size().i0;
     temporary_type aa=a, result(n, n);
 
     result = value_type_();
 
     result[diagonal()] = value_type_(1);
 
     for (int i=0; i<n; i++) {
         const block<0,1> blk(0, n-i);
         int i_max = i;
         value_type_ val_max = abs(aa(i, i));
 
         // find the strongest row
         for (int i2 = i+1; i2<n; i2++)
             if (abs(aa(i2, i)) > val_max) {
                 i_max = i2;
                 val_max = abs(aa(i2, i));
             }
 
         // swap row i_max with row i
         if (i_max != i) {
             typename transform_traits<temporary_type, row>::temporary_array res_tmp;
 
             res_tmp = result[row(i)];
             result[row(i)] = result[row(i_max)];
             result[row(i_max)] = res_tmp; 
 
             typename transform_traits<temporary_type, block<0,1> >::temporary_array org_tmp;
                 
             org_tmp = aa[blk(i,i)];
             aa[blk(i,i)] = aa[blk(i_max, i)];
             aa[blk(i_max,i)] = org_tmp; 
         }
 
         // if a singular matrix return a zero matrix
         if (aa(i, i) == value_type_()) {
             result = value_type_();
             break;
         }
 
         // normalize the row
         value_type_ factor = value_type_(1)/aa(i, i);
 
         result[row(i)] *= factor;
         aa[blk(i, i)] *= factor;
 
         value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;
 
         // simplify the column in the lower triangle
         for (int i2 = i+1; i2<n; i2++) 
             if (abs(aa(i2, i)) > epsilon) {
                 result[row(i2)] -= aa(i2, i)*result[row(i)];
                 aa[blk(i2,i)] -= aa(i2, i)*aa[blk(i,i)];
             }
     }
 
     // simplify the upper triangle
     for (int i = n-1; i>=0; i--) {
         value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;
 
         for (int i2 = 0; i2<i; i2++) 
             if (abs(aa(i2, i)) > epsilon) 
                 // we don't need to update the original here as it won't be used any more!
                 result[row(i2)] -= aa(i2, i)*result[row(i)];
     }
 
     return result;
 }
 
 /***********************************************************************************************************/
 /* rotation, 2D ********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
     >::type
 rotation_n(
     const array<value_type_[2], traits_type_, rep_>&, 
     const typename array_signature_traits<value_type_>::element_type& angle)
 {
     using namespace std;
     typename array_helper<value_type_[2][2], traits_type_>::temporary_array result;
 
     value_type_ tmp_cos = cos(angle);
     value_type_ tmp_sin = sin(angle);
 
     result(0, 0) = tmp_cos;
     result(1, 1) = tmp_cos;
     result(0, 1) = -tmp_sin;
     result(1, 0) = tmp_sin;
 
     return result;
 }
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
     >::type
 rotation(
     const array<value_type_[2], traits_type_, rep_>& dummy, 
     const typename array_signature_traits<value_type_>::element_type& angle)
 {
     return rotation_n(dummy, angle);
 }
 
 /***********************************************************************************************************/
 /* rotation, 3D ********************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
     >::type
 rotation_n(
     const array<value_type_[3], traits_type_, rep_>& axis, 
     const typename array_signature_traits<value_type_>::element_type& angle)
 {
     using namespace std;
 
     typedef array<value_type_[3], traits_type_, rep_> axis_type;
 
     typename detail::matrix_policy<axis_type, 9> ::cached_array cached_axis = axis;
     typename array_helper<value_type_[3][3], traits_type_>::temporary_array result;
 
     value_type_ tmp_cos = cos(angle);
     value_type_ tmp_sin = sin(angle);
     value_type_ tmp_rcos = value_type_(1) - tmp_cos;
 
     result(0, 0) = tmp_cos + cached_axis[0]*cached_axis[0]*tmp_rcos;
     result(1, 1) = tmp_cos + cached_axis[1]*cached_axis[1]*tmp_rcos;
     result(2, 2) = tmp_cos + cached_axis[2]*cached_axis[2]*tmp_rcos;
 
     value_type_ tmp1 = cached_axis[0]*cached_axis[1]*tmp_rcos;
     value_type_ tmp2 = cached_axis[2]*tmp_sin;
 
     result(1, 0) = tmp1 + tmp2;
     result(0, 1) = tmp1 - tmp2;
     tmp1 = cached_axis[0]*cached_axis[2]*tmp_rcos;
     tmp2 = cached_axis[1]*tmp_sin;
     result(2, 0) = tmp1 - tmp2;
     result(0, 2) = tmp1 + tmp2;    
     tmp1 = cached_axis[1]*cached_axis[2]*tmp_rcos;
     tmp2 = cached_axis[0]*tmp_sin;
     result(2, 1) = tmp1 + tmp2;
     result(1, 2) = tmp1 - tmp2;
 
     return result;
 }
 
 template<typename value_type_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
     >::type
 rotation(
     const array<value_type_[3], traits_type_, rep_>& axis, 
     const typename array_signature_traits<value_type_>::element_type& angle)
 {
     typename array_helper<value_type_[3], traits_type_>::temporary_array normalized_axis = axis;
 
     normalized_axis *= value_type_(1)/abs(normalized_axis);
 
     return rotation_n(normalized_axis, angle);
 }
 
 /***********************************************************************************************************/
 /* scale ***************************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename value_type_, int n_, typename traits_type_, typename rep_>
 LITE_INLINE 
 typename detail::enable_if<(
     array_signature_traits<value_type_>::dimensions == 0),
     const typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array
     >::type
 scale(const array<value_type_[n_], traits_type_, rep_>& factors)
 {
     const int n = factors.size().i0;
     typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array 
         result(n, n);
 
     result = value_type_();
     result[diagonal()] = factors;
     return result;
 }
 
 /***********************************************************************************************************/
 /* array_comparator ****************************************************************************************/
 /***********************************************************************************************************/
 
 class array_comparator
 {
 public:
     LITE_INLINE array_comparator() {}
 
     LITE_INLINE array_comparator(const array_comparator&) {}
 
     LITE_INLINE array_comparator& operator= (array_comparator&) { return *this; }
 
     template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
     LITE_INLINE bool 
     operator()(
         const array<signature_, traits_type_, l_rep_>& a, 
         const array<signature_, traits_type_, r_rep_>& b) const
     {
         return compare(a, b) < 0;
     }
 };
 
 /***********************************************************************************************************/
 /* from, fixed size ****************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename value_type_, int n0_ ..., int nN_>
 const array<...>
 from(value_type_ (&a)[n0_]...[nN_]);
 
 #else // DOCUMENTATION_ONLY
 
 template<
     typename value_type_,
     int n0_
 >
 LITE_INLINE 
 typename detail::enable_if<
     array_signature_traits<value_type_[n0_]>::is_fixed_size,
     const array<typename array_signature_traits<value_type_[n0_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_]>::default_iterator> > 
     >::type
 from(value_type_ (&a)[n0_])
 {
     typedef array<typename array_signature_traits<value_type_[n0_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_]>::default_iterator> 
         > result_type;
 
     return result_type(&a[0], typename result_type::size_type());
 };
 
 template<
     typename value_type_,
     int n0_,
     int n1_
 >
 LITE_INLINE 
 typename detail::enable_if<
     array_signature_traits<value_type_[n0_][n1_]>::is_fixed_size,
     const array<typename array_signature_traits<value_type_[n0_][n1_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_][n1_]>::default_iterator> > 
     >::type
 from(value_type_ (&a)[n0_][n1_])
 {
     typedef array<typename array_signature_traits<value_type_[n0_][n1_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_][n1_]>::default_iterator> 
         > result_type;
 
     return result_type(&a[0][0], typename result_type::size_type());
 };
 
 template<
     typename value_type_,
     int n0_,
     int n1_,
     int n2_
 >
 LITE_INLINE 
 typename detail::enable_if<
     array_signature_traits<value_type_[n0_][n1_][n2_]>::is_fixed_size,
     const array<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::default_iterator> > 
     >::type
 from(value_type_ (&a)[n0_][n1_][n2_])
 {
     typedef array<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::signature, 
         default_array_traits, 
         reference_rep<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::default_iterator> 
         > result_type;
 
     return result_type(&a[0][0][0], typename result_type::size_type());
 };
 
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* from, variable size *************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename iterator_type_>
 const array<...>
 from(iterator_type_ it, int n0 ..., int nN);
 
 #else // DOCUMENTATION_ONLY
 
 template<typename iterator_type_>
 LITE_INLINE 
 const array<
     typename std::iterator_traits<iterator_type_>::value_type[1],
     default_array_traits, 
     reference_rep<pack<iterator_type_, constant<int, 1> > > > 
 from(iterator_type_ it, int n0)
 {
     typedef array<
         typename std::iterator_traits<iterator_type_>::value_type[1],
         default_array_traits, 
         reference_rep<pack<iterator_type_, constant<int, 1> > > 
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, 1), 
         typename result_type::size_type(n0));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 const array<
     typename std::iterator_traits<iterator_type_>::value_type[1][1],
     default_array_traits, 
     reference_rep<pack<iterator_type_, int, constant<int, 1> > > > 
 from(iterator_type_ it, int n0, int n1)
 {
     typedef array<
         typename std::iterator_traits<iterator_type_>::value_type[1][1],
         default_array_traits, 
         reference_rep<pack<iterator_type_, int, constant<int, 1> > > 
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, n1, 1), 
         typename result_type::size_type(n0,n1));
 }
 
 template<typename iterator_type_>
 LITE_INLINE 
 const array<
     typename std::iterator_traits<iterator_type_>::value_type[1][1][1],
     default_array_traits, 
     reference_rep<pack<iterator_type_, int, int, constant<int, 1> > > > 
 from(iterator_type_ it, int n0, int n1, int n2)
 {
     typedef array<
         typename std::iterator_traits<iterator_type_>::value_type[1][1][1],
         default_array_traits, 
         reference_rep<pack<iterator_type_, int, int, constant<int, 1> > > 
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, n1*n2, n2, 1), 
         typename result_type::size_type(n0,n1,n2));
 }

   /*
template<typename iterator_type_>
 LITE_INLINE 
 const array<
     typename std::iterator_traits<iterator_type_>::value_type[1][1][1][1],
     default_array_traits, 
     reference_rep<pack<iterator_type_, int, int, int, constant<int, 1> > > > 
from(iterator_type_ it, int n0, int n1, int n2, int n3)
 {
     typedef array<
         typename std::iterator_traits<iterator_type_>::value_type[1][1][1][1],
         default_array_traits, 
         reference_rep<pack<iterator_type_, int, int, int, constant<int, 1> > > 
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
	 iterator_type(it, n1*n2*n3, n2*n3, n3, 1), 
         typename result_type::size_type(n0,n1,n2,n3));
	 }*/

 
 
 #endif // DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* from, pack size *****************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<typename iterator_type_, typename type0_ ..., typename typeN_>
 const array<...>
 from(iterator_type_ it, const pack<type0_ ..., typeN_>& size);
 
 #else // DOCUMENTATION_ONLY
 
 
 template<
     typename iterator_type_,
     typename type0_
 >
 LITE_INLINE 
 const array<
     typename detail::size_to_signature<
         pack<type0_>, 
         typename std::iterator_traits<iterator_type_>::value_type 
     >::type, 
     default_array_traits, 
     reference_rep<
         typename array_signature_traits<
             typename detail::size_to_signature<
                 pack<type0_>, 
                 typename std::iterator_traits<iterator_type_>::value_type 
             >::type,
             iterator_type_
         >::default_iterator>
     >
 from(
     iterator_type_ it, 
     const pack<type0_>& size) 
 {
     typedef array<
         typename detail::size_to_signature<
             pack<type0_>, 
             typename std::iterator_traits<iterator_type_>::value_type 
         >::type, 
         default_array_traits, 
         reference_rep<
             typename array_signature_traits<
                 typename detail::size_to_signature<
                     pack<type0_>, 
                     typename std::iterator_traits<iterator_type_>::value_type 
                 >::type,
                 iterator_type_
             >::default_iterator>
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, 1), 
         size);
 }
 
 template<
     typename iterator_type_,
     typename type0_,
     typename type1_
 >
 LITE_INLINE 
 const array<
     typename detail::size_to_signature<
         pack<type0_,type1_>, 
         typename std::iterator_traits<iterator_type_>::value_type 
     >::type, 
     default_array_traits, 
     reference_rep<
         typename array_signature_traits<
             typename detail::size_to_signature<
                 pack<type0_,type1_>, 
                 typename std::iterator_traits<iterator_type_>::value_type 
             >::type,
             iterator_type_
         >::default_iterator>
     >
 from(
     iterator_type_ it, 
     const pack<type0_, type1_>& size) 
 {
     typedef array<
         typename detail::size_to_signature<
             pack<type0_,type1_>, 
             typename std::iterator_traits<iterator_type_>::value_type 
         >::type, 
         default_array_traits, 
         reference_rep<
             typename array_signature_traits<
                 typename detail::size_to_signature<
                     pack<type0_,type1_>, 
                     typename std::iterator_traits<iterator_type_>::value_type 
                 >::type,
                 iterator_type_
             >::default_iterator>
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, size.i1, 1), 
         size);
 }
 
 template<
     typename iterator_type_,
     typename type0_,
     typename type1_,
     typename type2_
 >
 LITE_INLINE 
 const array<
     typename detail::size_to_signature<
         pack<type0_,type1_,type2_>, 
         typename std::iterator_traits<iterator_type_>::value_type 
     >::type, 
     default_array_traits, 
     reference_rep<
         typename array_signature_traits<
             typename detail::size_to_signature<
                 pack<type0_,type1_,type2_>, 
                 typename std::iterator_traits<iterator_type_>::value_type 
             >::type,
             iterator_type_
         >::default_iterator>
     >
 from(
     iterator_type_ it, 
     const pack<type0_, type1_, type2_>& size) 
 {
     typedef array<
         typename detail::size_to_signature<
             pack<type0_,type1_,type2_>, 
             typename std::iterator_traits<iterator_type_>::value_type 
         >::type, 
         default_array_traits, 
         reference_rep<
             typename array_signature_traits<
                 typename detail::size_to_signature<
                     pack<type0_,type1_,type2_>, 
                     typename std::iterator_traits<iterator_type_>::value_type 
                 >::type,
                 iterator_type_
             >::default_iterator>
         > result_type;
 
     typedef typename result_type::iterator iterator_type;
 
     return result_type(
         iterator_type(it, size.i1*size.i2, size.i2, 1), 
         size);
 }
 
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* from, identity ******************************************************************************************/
 /***********************************************************************************************************/
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE 
 array<signature_, traits_type_, rep_>&
 from(array<signature_, traits_type_, rep_>& a)
 {
     return a;
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE 
 const array<signature_, traits_type_, rep_>&
 from(const array<signature_, traits_type_, rep_>& a)
 {
     return a;
 }
 
 /***********************************************************************************************************/
 /* array_cast **********************************************************************************************/
 /***********************************************************************************************************/
 
 #ifdef DOCUMENTATION_ONLY
 
 template<
     typename dst_array_type_, 
     typename src_signature_, 
     typename src_traits_type_, 
     typename src_rep_>
 const array<...>
 array_cast(const array<src_signature_, src_traits_type_, src_rep_>& ar);
 
 #else // DOCUMENTATION_ONLY
 
 template<
     typename dst_array_type_, 
     typename src_signature_, 
     typename src_traits_type_, 
     typename src_rep_>
 LITE_INLINE 
 typename detail::enable_if<
     (array_signature_traits<src_signature_>::dimensions == dst_array_type_::dimensions),
     const array<
         typename dst_array_type_::signature,
         typename dst_array_type_::traits_type,
         reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::const_iterator> >
     >::type
 array_cast(const array<src_signature_, src_traits_type_, src_rep_>& a)
 {
     typedef array<
         typename dst_array_type_::signature,
         typename dst_array_type_::traits_type,
         reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::const_iterator> >
         result_type;
 
     typename result_type::size_type new_size(a.size());
    
     LITE_ARRAY_SIZE_CHECK(a.size(), new_size, "array_cast<A>(A): source/target sizes do not match");
 
     return result_type(a.begin(), new_size);
 }
 
 template<
     typename dst_array_type_, 
     typename src_signature_, 
     typename src_traits_type_, 
     typename src_rep_>
 LITE_INLINE 
 typename detail::enable_if<
     (array_signature_traits<src_signature_>::dimensions == dst_array_type_::dimensions),
     const array<
         typename dst_array_type_::signature,
         typename dst_array_type_::traits_type,
         reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::iterator> >
     >::type
 array_cast(array<src_signature_, src_traits_type_, src_rep_>& a)
 {
     typedef array<
         typename dst_array_type_::signature,
         typename dst_array_type_::traits_type,
         reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::iterator> >
         result_type;
 
     typename result_type::size_type new_size(a.size());
    
     LITE_ARRAY_SIZE_CHECK(a.size(), new_size, "array_cast<A>(A): source/target sizes do not match");
 
     return result_type(a.begin(), new_size);
 }
 
 #endif // !DOCUMENTATION_ONLY
 
 /***********************************************************************************************************/
 /* array io, operator<< ************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     typename traits_type_, 
     typename rep_>
 void print(
     std::basic_ostream<char_type_, char_traits_type_>& os, 
     const array<value_type_, traits_type_, rep_>& ar,
     int level
     )
 {       
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
     
     os.width(0);
 
     if (punct)
         os << '[';
 
     os.width(width);
     os << ar();
 
     if (punct)
         os << ']';
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     int n0_,
     typename traits_type_, 
     typename rep_>
 void print(
     std::basic_ostream<char_type_, char_traits_type_>& os, 
     const array<value_type_[n0_], traits_type_, rep_>& ar,
     int
     )
 {       
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
     const int n =ar.size().i0;
 
     os.width(0);
 
     if (punct)
         os << '[';
 
     for (int i=0; i<n; i++) {
         if (i != 0)
             os << ' ';
         os.width(width);
         os << ar[i];
     }
 
     if (punct)
         os << ']';
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename tail_type_, 
     int n0_,
     int n1_,
     typename traits_type_, 
     typename rep_>
 void print(
     std::basic_ostream<char_type_, char_traits_type_>& os, 
     const array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
     int level =0
     )
 {       
     std::streamsize width = os.width();
     bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
     const int n =ar.size().i0;
 
     os.width(0);
 
     if (punct) {
         os << '[' << '\n';
         for (int j=0; j<level; j++) { os.width(width); os << ' '; }
     }
     for (int i=0; i<n; i++) {
         os.width(width); 
         os << ' ';
         os.width(width);
         print(os, ar[row(i)], level+1);
         if (i < n-1) {
             os << "\n";
             for (int j=0; j<level; j++) { os.width(width); os << ' '; }
         }
     }
     if (punct) {
         os << '\n';
         for (int j=0; j<level; j++) { os.width(width); os << ' '; }
         os << ']';
     }
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename signature_, 
     typename traits_type_, 
     typename rep_>
 std::basic_ostream<char_type_, char_traits_type_>& 
 operator<<(
     std::basic_ostream<char_type_, char_traits_type_>& os, 
     const array<signature_, traits_type_, rep_>& ar)
 {
     print(os, ar, 0);
     return os;
 }
 
 /***********************************************************************************************************/
 /* array io, operator>> ************************************************************************************/
 /***********************************************************************************************************/
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     const array<value_type_, traits_type_, rep_>& ar,
     bool fancy
     )
 {
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     is >> ar();
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     array<value_type_, traits_type_, rep_>& ar,
     bool fancy
     )
 {
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     is >> ar();
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 /***********************************************************************************************************/
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     int n0_,
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     const array<value_type_[n0_], traits_type_, rep_>& ar,
     bool fancy
     )
 {
     const int n =ar.size().i0;
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     for (int i=0; i<n; i++)
         is >> ar[i];
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename value_type_, 
     int n0_,
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     array<value_type_[n0_], traits_type_, rep_>& ar,
     bool fancy
     )
 {
     const int n =ar.size().i0;
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     for (int i=0; i<n; i++)
         is >> ar[i];
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 /***********************************************************************************************************/
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename tail_type_, 
     int n0_,
     int n1_,
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     const array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
     bool fancy
     )
 {
     const int n =ar.size().i0;
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     for (int i=0; i<n; i++)
         scan(is, ar[row(i)], fancy);
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename tail_type_, 
     int n0_,
     int n1_,
     typename traits_type_, 
     typename rep_>
 void scan(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
     bool fancy
     )
 {
     const int n =ar.size().i0;
     char_type_ ch;
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 
     for (int i=0; i<n; i++)
         scan(is, ar[row(i)], fancy);
 
     ch = char_type_();
 
     if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
         is.setstate(std::ios_base::failbit);
         return;
     }
 }
 
 /***********************************************************************************************************/
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename signature_, 
     typename traits_type_, 
     typename rep_>
 std::basic_istream<char_type_, char_traits_type_>& 
 operator>>(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     const array<signature_, traits_type_, rep_>& ar)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     is.putback(ch);
     scan(is, ar, fancy);
     return is;
 }
 
 template<
     typename char_type_ , 
     typename char_traits_type_, 
     typename signature_, 
     typename traits_type_, 
     typename rep_>
 std::basic_istream<char_type_, char_traits_type_>& 
 operator>>(
     std::basic_istream<char_type_, char_traits_type_>& is, 
     array<signature_, traits_type_, rep_>& ar)
 {
     char_type_ ch;
 
     if (!(is >> ch))
         return is;
         
     bool fancy = is.narrow(ch, '\0') == '[';
 
     is.putback(ch);
     scan(is, ar, fancy);
     return is;
 }
 
 } // namespace lite
 
 /***********************************************************************************************************/
 /* swap ****************************************************************************************************/
 /***********************************************************************************************************/
 namespace std {
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE void 
 swap(
     const lite::array<signature_, traits_type_, rep_>& a, 
     const lite::array<signature_, traits_type_, rep_>& b)
 {
     a.swap(b);
 }
 
 template<typename signature_, typename traits_type_, typename rep_>
 LITE_INLINE void 
 swap(
     lite::array<signature_, traits_type_, rep_>& a, 
     lite::array<signature_, traits_type_, rep_>& b)
 {
     a.swap(b);
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE void 
 swap(
     const lite::array<signature_, traits_type_, l_rep_>& a, 
     const lite::array<signature_, traits_type_, r_rep_>& b)
 {
     a.swap(b);
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE void 
 swap(
     const lite::array<signature_, traits_type_, l_rep_>& a, 
     lite::array<signature_, traits_type_, r_rep_>& b)
 {
     a.swap(b);
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE void 
 swap(
     lite::array<signature_, traits_type_, l_rep_>& a, 
     const lite::array<signature_, traits_type_, r_rep_>& b)
 {
     a.swap(b);
 }
 
 template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
 LITE_INLINE void 
 swap(
     lite::array<signature_, traits_type_, l_rep_>& a, 
     lite::array<signature_, traits_type_, r_rep_>& b)
 {
     a.swap(b);
 }
 
 } // namespace std
 
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif // _MSC_VER
 
 #endif // LITE_ARRAY_HPP
 
 
 
